<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>nonlinearfit - Ruby/GSL (v1.16.0)</title>

<link href="../fonts.css" rel="stylesheet">
<link href="../rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
</script>

<script src="../js/jquery.js"></script>
<script src="../js/navigation.js"></script>
<script src="../js/search_index.js"></script>
<script src="../js/search.js"></script>
<script src="../js/searcher.js"></script>
<script src="../js/darkfish.js"></script>


<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../table_of_contents.html#pages">Pages</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>

  <ul class="link-list" role="directory">
    <li><a href="#label-Nonlinear+Least-Squares+Fitting">Nonlinear Least-Squares Fitting</a>
    <li><a href="#label-+Overview"><a href="index.html"name="1"></a> Overview</a>
    <li><a href="#label-+Initializing+the+Solver+"><a href="index.html"name="2"></a> Initializing the Solver </a>
    <li><a href="#label-+GSL%3A%3AMultiFit%3A%3AFdfSolver+class"><a href="index.html"name="2.1"></a> GSL::MultiFit::FdfSolver class</a>
    <li><a href="#label-+Providing+the+function+to+be+minimized"><a href="index.html"name="3"></a> Providing the function to be minimized</a>
    <li><a href="#label-+GSL%3A%3AMultiFit%3A%3AFunction_fdf+class"><a href="index.html"name="3.1"></a> GSL::MultiFit::Function_fdf class</a>
    <li><a href="#label-+Iteration"><a href="index.html"name="4"></a> Iteration</a>
    <li><a href="#label-+Search+Stopping+Parameters"><a href="index.html"name="5"></a> Search Stopping Parameters</a>
    <li><a href="#label-+Computing+the+covariance+matrix+of+best+fit+parameters"><a href="index.html"name="6"></a> Computing the covariance matrix of best fit parameters</a>
    <li><a href="#label-+Higher+level+interfaces"><a href="index.html"name="7"></a> Higher level interfaces</a>
    <li><a href="#label-+Examples"><a href="index.html"name="8"></a> Examples</a>
    <li><a href="#label-+Fitting+to+user-defined+functions"><a href="index.html"name="8.1"></a> Fitting to user-defined functions</a>
    <li><a href="#label-+Fitting+to+built-in+functions"><a href="index.html"name="8.2"></a> Fitting to built-in functions</a>
  </ul>
</div>


  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="../rdoc/alf_rdoc.html">alf</a>
  
    <li><a href="../rdoc/blas_rdoc.html">blas</a>
  
    <li><a href="../rdoc/bspline_rdoc.html">bspline</a>
  
    <li><a href="../rdoc/changes_rdoc.html">changes</a>
  
    <li><a href="../rdoc/cheb_rdoc.html">cheb</a>
  
    <li><a href="../rdoc/cholesky_complex_rdoc.html">cholesky_complex</a>
  
    <li><a href="../rdoc/combi_rdoc.html">combi</a>
  
    <li><a href="../rdoc/complex_rdoc.html">complex</a>
  
    <li><a href="../rdoc/const_rdoc.html">const</a>
  
    <li><a href="../rdoc/dht_rdoc.html">dht</a>
  
    <li><a href="../rdoc/diff_rdoc.html">diff</a>
  
    <li><a href="../rdoc/ehandling_rdoc.html">ehandling</a>
  
    <li><a href="../rdoc/eigen_rdoc.html">eigen</a>
  
    <li><a href="../rdoc/fft_rdoc.html">fft</a>
  
    <li><a href="../rdoc/fit_rdoc.html">fit</a>
  
    <li><a href="../rdoc/function_rdoc.html">function</a>
  
    <li><a href="../rdoc/graph_rdoc.html">graph</a>
  
    <li><a href="../rdoc/hist_rdoc.html">hist</a>
  
    <li><a href="../rdoc/hist2d_rdoc.html">hist2d</a>
  
    <li><a href="../rdoc/hist3d_rdoc.html">hist3d</a>
  
    <li><a href="../rdoc/index_rdoc.html">index</a>
  
    <li><a href="../rdoc/integration_rdoc.html">integration</a>
  
    <li><a href="../rdoc/interp_rdoc.html">interp</a>
  
    <li><a href="../rdoc/intro_rdoc.html">intro</a>
  
    <li><a href="../rdoc/linalg_rdoc.html">linalg</a>
  
    <li><a href="../rdoc/linalg_complex_rdoc.html">linalg_complex</a>
  
    <li><a href="../rdoc/math_rdoc.html">math</a>
  
    <li><a href="../rdoc/matrix_rdoc.html">matrix</a>
  
    <li><a href="../rdoc/min_rdoc.html">min</a>
  
    <li><a href="../rdoc/monte_rdoc.html">monte</a>
  
    <li><a href="../rdoc/multimin_rdoc.html">multimin</a>
  
    <li><a href="../rdoc/multiroot_rdoc.html">multiroot</a>
  
    <li><a href="../rdoc/narray_rdoc.html">narray</a>
  
    <li><a href="../rdoc/ndlinear_rdoc.html">ndlinear</a>
  
    <li><a href="../rdoc/nonlinearfit_rdoc.html">nonlinearfit</a>
  
    <li><a href="../rdoc/ntuple_rdoc.html">ntuple</a>
  
    <li><a href="../rdoc/odeiv_rdoc.html">odeiv</a>
  
    <li><a href="../rdoc/perm_rdoc.html">perm</a>
  
    <li><a href="../rdoc/poly_rdoc.html">poly</a>
  
    <li><a href="../rdoc/qrng_rdoc.html">qrng</a>
  
    <li><a href="../rdoc/randist_rdoc.html">randist</a>
  
    <li><a href="../rdoc/ref_rdoc.html">ref</a>
  
    <li><a href="../rdoc/rng_rdoc.html">rng</a>
  
    <li><a href="../rdoc/roots_rdoc.html">roots</a>
  
    <li><a href="../rdoc/screenshot_rdoc.html">screenshot</a>
  
    <li><a href="../rdoc/sf_rdoc.html">sf</a>
  
    <li><a href="../rdoc/siman_rdoc.html">siman</a>
  
    <li><a href="../rdoc/sort_rdoc.html">sort</a>
  
    <li><a href="../rdoc/start_rdoc.html">start</a>
  
    <li><a href="../rdoc/stats_rdoc.html">stats</a>
  
    <li><a href="../rdoc/sum_rdoc.html">sum</a>
  
    <li><a href="../rdoc/tensor_rdoc.html">tensor</a>
  
    <li><a href="../rdoc/tut_rdoc.html">tut</a>
  
    <li><a href="../rdoc/use_rdoc.html">use</a>
  
    <li><a href="../rdoc/vector_rdoc.html">vector</a>
  
    <li><a href="../rdoc/vector_complex_rdoc.html">vector_complex</a>
  
    <li><a href="../rdoc/wavelet_rdoc.html">wavelet</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page rdoc/nonlinearfit.rdoc">

<h1 id="label-Nonlinear+Least-Squares+Fitting">Nonlinear Least-Squares Fitting<span><a href="#label-Nonlinear+Least-Squares+Fitting">&para;</a> <a href="#documentation">&uarr;</a></span></h1>

<p>This chapter describes functions for multidimensional nonlinear
least-squares  fitting. The library provides low level components for a
variety of iterative  solvers and convergence tests. These can be combined
by the user to achieve  the desired solution, with full access to the
intermediate steps of the  iteration. Each class of methods uses the same
framework, so that you can  switch between solvers at runtime without
needing to recompile your program.  Each instance of a solver keeps track
of its own state, allowing the solvers  to be used in multi-threaded
programs.</p>

<p>Contents:</p>
<ol><li>
<p><a href="nonlinearfit_rdoc.html#1">Overview</a></p>
</li><li>
<p><a href="nonlinearfit_rdoc.html#2">Initializing the Solver</a></p>
<ol><li>
<p><a href="nonlinearfit_rdoc.html#2.1">GSL::MultiFit::FdfSolver class</a></p>
</li></ol>
</li><li>
<p><a href="nonlinearfit_rdoc.html#3">Providing the function to be
minimized</a></p>
<ol><li>
<p><a href="nonlinearfit_rdoc.html#3.1">GSL::MultiFit::Function_fdf class</a></p>
</li></ol>
</li><li>
<p><a href="nonlinearfit_rdoc.html#4">Iteration</a></p>
</li><li>
<p><a href="nonlinearfit_rdoc.html#5">Search Stopping Parameters</a></p>
</li><li>
<p><a href="nonlinearfit_rdoc.html#6">Computing the covariance matrix of best
fit parameters</a></p>
</li><li>
<p><a href="nonlinearfit_rdoc.html#7">Higher level interfaces</a></p>
</li><li>
<p><a href="nonlinearfit_rdoc.html#8">Examples</a></p>
<ol><li>
<p><a href="nonlinearfit_rdoc.html#8.1">Fitting to user-defined functions</a></p>
</li><li>
<p><a href="nonlinearfit_rdoc.html#8.2">Fitting to built-in functions</a></p>
</li></ol>
</li></ol>

<h2 id="label-+Overview"><a href="../index.html"name="1"></a> Overview<span><a href="#label-+Overview">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>The problem of multidimensional nonlinear least-squares fitting requires
the  minimization of the squared residuals of n functions, f_i, in p
parameters,  x_i, All algorithms proceed from an initial guess using the
linearization,  where x is the initial point, p is the proposed step and J
is the Jacobian  matrix J_{ij} = d f_i / d x_j. Additional strategies are
used to enlarge the  region of convergence. These include requiring a
decrease in the norm ||F||  on each step or using a trust region to avoid
steps which fall outside the  linear regime.</p>

<p>To perform a weighted least-squares fit of a nonlinear model Y(x,t) to data
(t_i, y_i) with independent gaussian errors sigma_i, use function
components  of the following form, Note that the model parameters are
denoted by x in this  chapter since the non-linear least-squares algorithms
are described  geometrically (i.e. finding the minimum of a surface). The
independent  variable of any data to be fitted is denoted by t.</p>

<p>With the definition above the Jacobian is  J_{ij} =(1 / sigma_i) d Y_i / d
x_j, where Y_i = Y(x,t_i).</p>

<h2 id="label-+Initializing+the+Solver+"><a href="../index.html"name="2"></a> Initializing the Solver <span><a href="#label-+Initializing+the+Solver+">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<h3 id="label-+GSL%3A%3AMultiFit%3A%3AFdfSolver+class"><a href="../index.html"name="2.1"></a> GSL::MultiFit::FdfSolver class<span><a href="#label-+GSL%3A%3AMultiFit%3A%3AFdfSolver+class">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::MultiFit::FdfSolver.alloc(T, n, p)</p>

<p>This creates an instance of the <code>GSL::MultiFit::FdfSolver</code> class
of  type <code>T</code> for <code>n</code> observations and <code>p</code>
parameters. The type <code>T</code> is given by a <code>Fixnum</code>
constant or a <code>String</code>,</p>
<ul><li>
<p><code>GSL::MultiFit::LMSDER</code> or <code>&quot;lmsder&quot;</code></p>
</li><li>
<p><code>GSL::MultiFit::LMDER</code> or <code>&quot;lmder&quot;</code></p>
</li></ul>

<p>For example, the following code creates an instance of a
Levenberg-Marquardt  solver for 100 data points and 3 parameters,</p>

<pre>solver = MultiFit::FdfSolver.alloc(MultiFit::LMDER, 100, 3)</pre>
</li></ul>
<hr>
<ul><li>
<p>GSL::MultiFit::FdfSolver#set(f, x)</p>

<p>This method initializes, or reinitializes, an existing solver
<code>self</code>  to use the function <code>f</code> and the initial guess
<code>x</code>. The function <code>f</code> is an instance of the
<code>GSL::MultiFit::Function_fdf</code> class (see below). The initial
guess of the parameters <code>x</code> is given by a <a
href="vector_rdoc.html">GSL::Vector</a> object.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::MultiFit::FdfSolver#name</p>

<p>This returns the name of the solver <code>self</code> as a String.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::MultiFit::FdfSolver#x</p>
</li><li>
<p>GSL::MultiFit::FdfSolver#dx</p>
</li><li>
<p>GSL::MultiFit::FdfSolver#f</p>
</li><li>
<p>GSL::MultiFit::FdfSolver#J</p>
</li><li>
<p>GSL::MultiFit::FdfSolver#jacobian</p>
</li><li>
<p>GSL::MultiFit::FdfSolver#jac</p>

<p>Access to the members (see <code>gsl_multifit_nlin.h</code>)</p>
</li></ul>

<h2 id="label-+Providing+the+function+to+be+minimized"><a href="../index.html"name="3"></a> Providing the function to be minimized<span><a href="#label-+Providing+the+function+to+be+minimized">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<h3 id="label-+GSL%3A%3AMultiFit%3A%3AFunction_fdf+class"><a href="../index.html"name="3.1"></a> GSL::MultiFit::Function_fdf class<span><a href="#label-+GSL%3A%3AMultiFit%3A%3AFunction_fdf+class">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::MultiFit::Function_fdf.alloc()</p>
</li><li>
<p>GSL::MultiFit::Function_fdf.alloc(f, df, p)</p>
</li><li>
<p>GSL::MultiFit::Function_fdf.alloc(f, df, fdf, p)</p>

<p>Constructor for the <code>Function_fdf</code> class, to a function with
<code>p</code> parameters, The first two or three arguments are Ruby Proc
objects  to evaluate the function to minimize and its derivative
(Jacobian).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::MultiFit::Function_fdf#set_procs(f, df, p)</p>
</li><li>
<p>GSL::MultiFit::Function_fdf#set_procs(f, df, fdf, p)</p>

<p>This initialize of reinitialize the function <code>self</code> with
<code>p</code> parameters by two or three Proc objects <code>f, df</code>
and <code>fdf</code>.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::MultiFit::Function_fdf#set_data(t, y)</p>
</li><li>
<p>GSL::MultiFit::Function_fdf#set_data(t, y, sigma)</p>

<p>This sets the data <code>t, y, sigma</code> of length <code>n</code>, to
the function <code>self</code>.</p>
</li></ul>

<h2 id="label-+Iteration"><a href="../index.html"name="4"></a> Iteration<span><a href="#label-+Iteration">&para;</a> <a href="#documentation">&uarr;</a></span></h2>
<hr>
<ul><li>
<p>GSL::MultiFit::FdfSolver#iterate</p>

<p>THis performs a single iteration of the solver <code>self</code>. If the
iteration  encounters an unexpected problem then an error code will be
returned.  The solver maintains a current estimate of the best-fit
parameters at all  times. This information can be accessed with the method
<code>position</code>.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::MultiFit::FdfSolver#position</p>

<p>This returns the current position (i.e. best-fit parameters) of the solver 
<code>self</code>, as a <code>GSL::Vector</code> object.</p>
</li></ul>

<h2 id="label-+Search+Stopping+Parameters"><a href="../index.html"name="5"></a> Search Stopping Parameters<span><a href="#label-+Search+Stopping+Parameters">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>A minimization procedure should stop when one of the following conditions
is true:</p>
<ul><li>
<p>A minimum has been found to within the user-specified precision.</p>
</li><li>
<p>A user-specified maximum number of iterations has been reached.</p>
</li><li>
<p>An error has occurred.</p>
</li></ul>

<p>The handling of these conditions is under user control. The method below
allows the user to test the current estimate of the best-fit parameters.</p>
<hr>
<ul><li>
<p>GSL::MultiFit::FdfSolver#test_delta(epsabs, epsrel)</p>

<p>This method tests for the convergence of the sequence by comparing the last
step with the absolute error <code>epsabs</code> and relative error
(<code>epsrel</code>  to the current position. The test returns
<code>GSL::SUCCESS</code> if the following  condition is achieved,</p>

<pre>|dx_i| &lt; epsabs + epsrel |x_i|</pre>

<p>for each component of <code>x</code> and returns <code>GSL::CONTINUE</code>
otherwise.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::MultiFit::FdfSolver#test_gradient(g, epsabs)</p>
</li><li>
<p>GSL::MultiFit::FdfSolver#test_gradient(epsabs)</p>

<p>This function tests the residual gradient <code>g</code> against the
absolute error  bound <code>epsabs</code>. If <code>g</code> is not given,
it is calculated internally.  Mathematically, the gradient should be
exactly zero at the minimum.  The test returns <code>GSL::SUCCESS</code> if
the following condition is achieved,</p>

<pre>\sum_i |g_i| &lt; epsabs</pre>

<p>and returns <code>GSL::CONTINUE</code> otherwise. This criterion is
suitable for  situations where the precise location of the minimum, x, is
unimportant provided  a value can be found where the gradient is small
enough.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::MultiFit::FdfSolver#gradient</p>

<p>This method returns the gradient g of Phi(x) = (1/2) ||F(x)||^2 from the 
Jacobian matrix and the function values, using the formula g = J^T f.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::MultiFit.test_delta(dx, x, epsabs, epsrel)</p>
</li><li>
<p>GSL::MultiFit.test_gradient(g, epsabs)</p>
</li><li>
<p>GSL::MultiFit.gradient(jac, f, g)</p>
</li><li>
<p>GSL::MultiFit.covar(jac, epsrel)</p>
</li><li>
<p>GSL::MultiFit.covar(jac, epsrel, covar)</p>

<p>Singleton methods of the <code>GSL::MultiFit</code> module.</p>
</li></ul>

<h2 id="label-+Computing+the+covariance+matrix+of+best+fit+parameters"><a href="../index.html"name="6"></a> Computing the covariance matrix of best fit parameters<span><a href="#label-+Computing+the+covariance+matrix+of+best+fit+parameters">&para;</a> <a href="#documentation">&uarr;</a></span></h2>
<hr>
<ul><li>
<p>GSL::MultiFit.covar(J, epsrel)</p>
</li><li>
<p>GSL::MultiFit.covar(J, epsrel, covar)</p>

<p>This method uses the Jacobian matrix <code>J</code> to compute the
covariance  matrix of the best-fit parameters. If an existing matrix
<code>covar</code> is given, it is overwritten, and if not, this method
returns a new matrix.  The parameter <code>epsrel</code> is used to remove
linear-dependent columns when  <code>J</code> is rank deficient.</p>

<p>The covariance matrix is given by,</p>

<pre>covar = (J^T J)^{-1}</pre>

<p>and is computed by QR decomposition of <code>J</code> with column-pivoting.
Any columns of R which satisfy</p>

<pre>|R_{kk}| &lt;= epsrel |R_{11}|</pre>

<p>are considered linearly-dependent and are excluded from the covariance
matrix  (the corresponding rows and columns of the covariance matrix are
set to zero).</p>
</li></ul>

<h2 id="label-+Higher+level+interfaces"><a href="../index.html"name="7"></a> Higher level interfaces<span><a href="#label-+Higher+level+interfaces">&para;</a> <a href="#documentation">&uarr;</a></span></h2>
<hr>
<ul><li>
<p>GSL::MultiFit::FdfSolver.fit(x, y, type[, guess])</p>
</li><li>
<p>GSL::MultiFit::FdfSolver.fit(x, w, y, type[, guess])</p>

<p>This method uses <code>FdfSolver</code> with the LMSDER algorithm to fit
the data <code>[x, y]</code> to a function of type <code>type</code>. The
returned value is  an array of 4 elements, <code>[coef, err, chisq,
dof]</code>, where <code>coef</code> is an array of the fitting
coefficients, <code>err</code> contains errors in estimating
<code>coef</code>, <code>chisq</code> is the  chi-squared, and
<code>dof</code> is the degree-of-freedom in the fitting  which equals to
(data length - number of fitting coefficients). The optional argument
<code>guess</code> is an array of initial guess of the coefficients. The
fitting type <code>type</code> is given by a <code>String</code> as
follows.</p>
<ul><li>
<p><code>&quot;gaussian&quot;</code>: Gaussian fit,  <code>y = y0 + A
exp(-(x-x0)^2/2/var)</code>, <code>coef = [y0, A, x0, var]</code></p>
</li><li>
<p><code>&quot;gaussian_2peaks&quot;</code>: 2-peak Gaussian fit, <code>y = y0
+ A1 exp(-(x-x1)^2/2/var1) + A2 exp(-(x-x2)^2/2/var2)</code>, <code>coef =
[y0, A1, x1, var1, A2, x2, var2]</code></p>
</li><li>
<p><code>&quot;exp&quot;</code>: Exponential fit,  <code>y = y0 + A exp(-b
x)</code>, <code>coef = [y0, A, b]</code></p>
</li><li>
<p><code>&quot;dblexp&quot;</code>: Double exponential fit,  <code>y = y0 + A1
exp(-b1 x) + A2 exp(-b2 x)</code>, <code>coef = [y0, A1, b1, A2, b2]</code></p>
</li><li>
<p><code>&quot;sin&quot;</code>: Sinusoidal fit,  <code>y = y0 + A sin(f x +
phi)</code>, <code>coef = [y0, A, f, phi]</code></p>
</li><li>
<p><code>&quot;lor&quot;</code>: Lorentzian peak fit,  <code>y = y0 +
A/((x-x0)^2 + B)</code>, <code>coef = [y0, A, x0, B]</code></p>
</li><li>
<p><code>&quot;hill&quot;</code>: Hill&#39;s equation fit,  <code>y = y0 + (m
- y0)/(1 + (xhalf/x)^r)</code>, <code>coef = [y0, n, xhalf, r]</code></p>
</li><li>
<p><code>&quot;sigmoid&quot;</code>: Sigmoid (Fermi-Dirac) function fit, 
<code>y = y0 + m/(1 + exp((x0-x)/r))</code>, <code>coef = [y0, m, x0,
r]</code></p>
</li><li>
<p><code>&quot;power&quot;</code>: Power-law fit,  <code>y = y0 + A
x^r</code>, <code>coef = [y0, A, r]</code></p>
</li><li>
<p><code>&quot;lognormal&quot;</code>: Lognormal peak fit,  <code>y = y0 + A
exp[ -(log(x/x0)/width)^2 ]</code>, <code>coef = [y0, A, x0, width]</code></p>
</li></ul>

<p>See <a href="fit_rdoc.html#2.3">Linear fitting</a> for linear and
polynomical fittings.</p>
</li></ul>

<h2 id="label-+Examples"><a href="../index.html"name="8"></a> Examples<span><a href="#label-+Examples">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<h3 id="label-+Fitting+to+user-defined+functions"><a href="../index.html"name="8.1"></a> Fitting to user-defined functions<span><a href="#label-+Fitting+to+user-defined+functions">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>The following example program fits a weighted exponential model with
background  to experimental data, Y = A exp(-lambda t) + b. The first part
of the program sets  up the functions <code>procf</code> and
<code>procdf</code> to calculate the model and its Jacobian.  The
appropriate fitting function is given by,</p>

<pre>f_i = ((A exp(-lambda t_i) + b) - y_i)/sigma_i</pre>

<p>where we have chosen t_i = i. The Jacobian matrix <code>jac</code> is the
derivative of  these functions with respect to the three parameters (A,
lambda, b). It is given by,</p>

<pre>J_{ij} = d f_i / d x_j</pre>

<p>where x_0 = A, x_1 = lambda and x_2 = b.</p>

<pre class="ruby"><span class="ruby-identifier">require</span>(<span class="ruby-string">&quot;gsl&quot;</span>)
<span class="ruby-identifier">include</span> <span class="ruby-constant">GSL</span><span class="ruby-operator">::</span><span class="ruby-constant">MultiFit</span>

<span class="ruby-comment"># x: Vector, list of the parameters to determine</span>
<span class="ruby-comment"># t, y, sigma: Vectors, observational data</span>
<span class="ruby-comment"># f: Vector, function to minimize</span>
<span class="ruby-identifier">procf</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span>, <span class="ruby-identifier">t</span>, <span class="ruby-identifier">y</span>, <span class="ruby-identifier">sigma</span>, <span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">a</span> = <span class="ruby-identifier">x</span>[<span class="ruby-value">0</span>]
  <span class="ruby-identifier">lambda</span> = <span class="ruby-identifier">x</span>[<span class="ruby-value">1</span>]
  <span class="ruby-identifier">b</span> = <span class="ruby-identifier">x</span>[<span class="ruby-value">2</span>]
  <span class="ruby-identifier">n</span> = <span class="ruby-identifier">t</span>.<span class="ruby-identifier">size</span>
  <span class="ruby-keyword">for</span> <span class="ruby-identifier">i</span> <span class="ruby-keyword">in</span> <span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-identifier">n</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">yi</span> = <span class="ruby-identifier">a</span><span class="ruby-operator">*</span><span class="ruby-constant">Math</span><span class="ruby-operator">::</span><span class="ruby-identifier">exp</span>(<span class="ruby-operator">-</span><span class="ruby-identifier">lambda</span><span class="ruby-operator">*</span><span class="ruby-identifier">t</span>[<span class="ruby-identifier">i</span>]) <span class="ruby-operator">+</span> <span class="ruby-identifier">b</span>
    <span class="ruby-identifier">f</span>[<span class="ruby-identifier">i</span>] = (<span class="ruby-identifier">yi</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">y</span>[<span class="ruby-identifier">i</span>])<span class="ruby-operator">/</span><span class="ruby-identifier">sigma</span>[<span class="ruby-identifier">i</span>]
  <span class="ruby-keyword">end</span>
}

<span class="ruby-comment"># jac: Matrix, Jacobian</span>
<span class="ruby-identifier">procdf</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span>, <span class="ruby-identifier">t</span>, <span class="ruby-identifier">y</span>, <span class="ruby-identifier">sigma</span>, <span class="ruby-identifier">jac</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">a</span> = <span class="ruby-identifier">x</span>[<span class="ruby-value">0</span>]
  <span class="ruby-identifier">lambda</span> = <span class="ruby-identifier">x</span>[<span class="ruby-value">1</span>]
  <span class="ruby-identifier">n</span> = <span class="ruby-identifier">t</span>.<span class="ruby-identifier">size</span>
  <span class="ruby-keyword">for</span> <span class="ruby-identifier">i</span> <span class="ruby-keyword">in</span> <span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-identifier">n</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">ti</span> = <span class="ruby-identifier">t</span>[<span class="ruby-identifier">i</span>]
    <span class="ruby-identifier">si</span> = <span class="ruby-identifier">sigma</span>[<span class="ruby-identifier">i</span>]
    <span class="ruby-identifier">ei</span> = <span class="ruby-constant">Math</span><span class="ruby-operator">::</span><span class="ruby-identifier">exp</span>(<span class="ruby-operator">-</span><span class="ruby-identifier">lambda</span><span class="ruby-operator">*</span><span class="ruby-identifier">ti</span>)
    <span class="ruby-identifier">jac</span>.<span class="ruby-identifier">set</span>(<span class="ruby-identifier">i</span>, <span class="ruby-value">0</span>, <span class="ruby-identifier">ei</span><span class="ruby-operator">/</span><span class="ruby-identifier">si</span>)
    <span class="ruby-identifier">jac</span>.<span class="ruby-identifier">set</span>(<span class="ruby-identifier">i</span>, <span class="ruby-value">1</span>, <span class="ruby-operator">-</span><span class="ruby-identifier">ti</span><span class="ruby-operator">*</span><span class="ruby-identifier">a</span><span class="ruby-operator">*</span><span class="ruby-identifier">ei</span><span class="ruby-operator">/</span><span class="ruby-identifier">si</span>)
    <span class="ruby-identifier">jac</span>.<span class="ruby-identifier">set</span>(<span class="ruby-identifier">i</span>, <span class="ruby-value">2</span>, <span class="ruby-value">1.0</span><span class="ruby-operator">/</span><span class="ruby-identifier">si</span>)
  <span class="ruby-keyword">end</span>
}

<span class="ruby-identifier">f</span> = <span class="ruby-constant">GSL</span><span class="ruby-operator">::</span><span class="ruby-constant">MultiFit</span><span class="ruby-operator">::</span><span class="ruby-constant">Function_fdf</span>.<span class="ruby-identifier">alloc</span>(<span class="ruby-identifier">procf</span>, <span class="ruby-identifier">procdf</span>, <span class="ruby-value">2</span>)

<span class="ruby-comment"># Create data</span>
<span class="ruby-identifier">r</span> = <span class="ruby-constant">GSL</span><span class="ruby-operator">::</span><span class="ruby-constant">Rng</span>.<span class="ruby-identifier">alloc</span>()
<span class="ruby-identifier">t</span> = <span class="ruby-constant">GSL</span><span class="ruby-operator">::</span><span class="ruby-constant">Vector</span>.<span class="ruby-identifier">alloc</span>(<span class="ruby-identifier">n</span>)
<span class="ruby-identifier">y</span> = <span class="ruby-constant">GSL</span><span class="ruby-operator">::</span><span class="ruby-constant">Vector</span>.<span class="ruby-identifier">alloc</span>(<span class="ruby-identifier">n</span>)
<span class="ruby-identifier">sigma</span> = <span class="ruby-constant">Vector</span>.<span class="ruby-identifier">alloc</span>(<span class="ruby-identifier">n</span>)
<span class="ruby-keyword">for</span> <span class="ruby-identifier">i</span> <span class="ruby-keyword">in</span> <span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-identifier">n</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">t</span>[<span class="ruby-identifier">i</span>] = <span class="ruby-identifier">i</span>
  <span class="ruby-identifier">y</span>[<span class="ruby-identifier">i</span>] = <span class="ruby-value">1.0</span> <span class="ruby-operator">+</span> <span class="ruby-value">5</span><span class="ruby-operator">*</span><span class="ruby-constant">Math</span><span class="ruby-operator">::</span><span class="ruby-identifier">exp</span>(<span class="ruby-value">-0.1</span><span class="ruby-operator">*</span><span class="ruby-identifier">t</span>[<span class="ruby-identifier">i</span>]) <span class="ruby-operator">+</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">gaussian</span>(<span class="ruby-value">0.1</span>)
  <span class="ruby-identifier">sigma</span>[<span class="ruby-identifier">i</span>] = <span class="ruby-value">0.1</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">f</span>.<span class="ruby-identifier">set_data</span>(<span class="ruby-identifier">t</span>, <span class="ruby-identifier">y</span>, <span class="ruby-identifier">sigma</span>)
<span class="ruby-identifier">x</span> = <span class="ruby-constant">GSL</span><span class="ruby-operator">::</span><span class="ruby-constant">Vector</span>.<span class="ruby-identifier">alloc</span>(<span class="ruby-value">1.0</span>, <span class="ruby-value">0.0</span>, <span class="ruby-value">0.0</span>)    <span class="ruby-comment"># initial guess</span>

<span class="ruby-identifier">solver</span> = <span class="ruby-constant">GSL</span><span class="ruby-operator">::</span><span class="ruby-constant">FdfSolver</span>.<span class="ruby-identifier">alloc</span>(<span class="ruby-constant">FdfSolver</span><span class="ruby-operator">::</span><span class="ruby-constant">LMSDER</span>, <span class="ruby-identifier">n</span>, <span class="ruby-identifier">np</span>)

<span class="ruby-identifier">solver</span>.<span class="ruby-identifier">set</span>(<span class="ruby-identifier">f</span>, <span class="ruby-identifier">x</span>)

<span class="ruby-identifier">iter</span> = <span class="ruby-value">0</span>
<span class="ruby-identifier">solver</span>.<span class="ruby-identifier">print_state</span>(<span class="ruby-identifier">iter</span>)
<span class="ruby-keyword">begin</span>
  <span class="ruby-identifier">iter</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
  <span class="ruby-identifier">status</span> = <span class="ruby-identifier">solver</span>.<span class="ruby-identifier">iterate</span>
  <span class="ruby-identifier">solver</span>.<span class="ruby-identifier">print_state</span>(<span class="ruby-identifier">iter</span>)
  <span class="ruby-identifier">status</span> = <span class="ruby-identifier">solver</span>.<span class="ruby-identifier">test_delta</span>(<span class="ruby-value">1e-4</span>, <span class="ruby-value">1e-4</span>)
<span class="ruby-keyword">end</span> <span class="ruby-keyword">while</span> <span class="ruby-identifier">status</span> <span class="ruby-operator">==</span> <span class="ruby-constant">GSL</span><span class="ruby-operator">::</span><span class="ruby-constant">CONTINUE</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">iter</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">500</span>

<span class="ruby-identifier">covar</span> = <span class="ruby-identifier">solver</span>.<span class="ruby-identifier">covar</span>(<span class="ruby-value">0.0</span>)
<span class="ruby-identifier">position</span> = <span class="ruby-identifier">solver</span>.<span class="ruby-identifier">position</span>
<span class="ruby-identifier">chi2</span> = <span class="ruby-identifier">pow_2</span>(<span class="ruby-identifier">solver</span>.<span class="ruby-identifier">f</span>.<span class="ruby-identifier">dnrm2</span>)
<span class="ruby-identifier">dof</span> = <span class="ruby-identifier">n</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">np</span>
<span class="ruby-identifier">printf</span>(<span class="ruby-string">&quot;A      = %.5f +/- %.5f\n&quot;</span>, <span class="ruby-identifier">position</span>[<span class="ruby-value">0</span>], <span class="ruby-constant">Math</span><span class="ruby-operator">::</span><span class="ruby-identifier">sqrt</span>(<span class="ruby-identifier">chi2</span><span class="ruby-operator">/</span><span class="ruby-identifier">dof</span><span class="ruby-operator">*</span><span class="ruby-identifier">covar</span>[<span class="ruby-value">0</span>][<span class="ruby-value">0</span>]))
<span class="ruby-identifier">printf</span>(<span class="ruby-string">&quot;lambda = %.5f +/- %.5f\n&quot;</span>, <span class="ruby-identifier">position</span>[<span class="ruby-value">1</span>], <span class="ruby-constant">Math</span><span class="ruby-operator">::</span><span class="ruby-identifier">sqrt</span>(<span class="ruby-identifier">chi2</span><span class="ruby-operator">/</span><span class="ruby-identifier">dof</span><span class="ruby-operator">*</span><span class="ruby-identifier">covar</span>[<span class="ruby-value">1</span>][<span class="ruby-value">1</span>]))
<span class="ruby-identifier">printf</span>(<span class="ruby-string">&quot;b      = %.5f +/- %.5f\n&quot;</span>, <span class="ruby-identifier">position</span>[<span class="ruby-value">2</span>], <span class="ruby-constant">Math</span><span class="ruby-operator">::</span><span class="ruby-identifier">sqrt</span>(<span class="ruby-identifier">chi2</span><span class="ruby-operator">/</span><span class="ruby-identifier">dof</span><span class="ruby-operator">*</span><span class="ruby-identifier">covar</span>[<span class="ruby-value">2</span>][<span class="ruby-value">2</span>]))
</pre>

<h3 id="label-+Fitting+to+built-in+functions"><a href="../index.html"name="8.2"></a> Fitting to built-in functions<span><a href="#label-+Fitting+to+built-in+functions">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<pre>#!/usr/bin/env ruby
require(&quot;gsl&quot;)
include MultiFit

N = 100

y0 = 1.0
A = 2.0
x0 = 3.0
w = 0.5

r = Rng.alloc
x = Vector.linspace(0.01, 10, N)
sig = 1
# Lognormal function with noise
y =  y0 + A*Sf::exp(-pow_2(Sf::log(x/x0)/w)) + 0.1*Ran::gaussian(r, sig, N)

guess = [0, 3, 2, 1]
coef, err, chi2, dof = MultiFit::FdfSolver.fit(x, y, &quot;lognormal&quot;, guess)
y0 = coef[0]
amp = coef[1]
x0 = coef[2]
w = coef[3]

graph(x, y, y0+amp*Sf::exp(-pow_2(Sf::log(x/x0)/w)))</pre>

<p><a href="fit_rdoc.html">prev</a> <a href="bspline_rdoc.html">next</a></p>

<p><a href="ref_rdoc.html">Reference index</a> <a href="../index.html">top</a></p>
</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://rdoc.rubyforge.org">RDoc</a> 4.1.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

