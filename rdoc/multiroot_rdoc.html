<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>multiroot - Ruby/GSL (v1.15.3.2)</title>

<link href="../fonts.css" rel="stylesheet">
<link href="../rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
</script>

<script src="../js/jquery.js"></script>
<script src="../js/navigation.js"></script>
<script src="../js/search_index.js"></script>
<script src="../js/search.js"></script>
<script src="../js/searcher.js"></script>
<script src="../js/darkfish.js"></script>


<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../table_of_contents.html#pages">Pages</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>

  <ul class="link-list" role="directory">
    <li><a href="#label-Multidimensional+Root-Finding">Multidimensional Root-Finding</a>
    <li><a href="#label-+Overview"><a href="index.html"name="1"></a> Overview</a>
    <li><a href="#label-+Initializing+the+Solver"><a href="index.html"name="2"></a> Initializing the Solver</a>
    <li><a href="#label-+Providing+the+function+to+solve"><a href="index.html"name="3"></a> Providing the function to solve</a>
    <li><a href="#label-+Iteration"><a href="index.html"name="4"></a> Iteration</a>
    <li><a href="#label-+Search+Stopping+Parameters"><a href="index.html"name="5"></a> Search Stopping Parameters</a>
    <li><a href="#label-+Higher+Level+Interface"><a href="index.html"name="6"></a> Higher Level Interface</a>
    <li><a href="#label-+Example"><a href="index.html"name="7"></a> Example</a>
    <li><a href="#label-+FSolver"><a href="index.html"name="7.1"></a> FSolver</a>
    <li><a href="#label-+FdfSolver"><a href="index.html"name="7.2"></a> FdfSolver</a>
  </ul>
</div>


  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="../rdoc/alf_rdoc.html">alf</a>
  
    <li><a href="../rdoc/blas_rdoc.html">blas</a>
  
    <li><a href="../rdoc/bspline_rdoc.html">bspline</a>
  
    <li><a href="../rdoc/changes_rdoc.html">changes</a>
  
    <li><a href="../rdoc/cheb_rdoc.html">cheb</a>
  
    <li><a href="../rdoc/cholesky_complex_rdoc.html">cholesky_complex</a>
  
    <li><a href="../rdoc/combi_rdoc.html">combi</a>
  
    <li><a href="../rdoc/complex_rdoc.html">complex</a>
  
    <li><a href="../rdoc/const_rdoc.html">const</a>
  
    <li><a href="../rdoc/dht_rdoc.html">dht</a>
  
    <li><a href="../rdoc/diff_rdoc.html">diff</a>
  
    <li><a href="../rdoc/ehandling_rdoc.html">ehandling</a>
  
    <li><a href="../rdoc/eigen_rdoc.html">eigen</a>
  
    <li><a href="../rdoc/fft_rdoc.html">fft</a>
  
    <li><a href="../rdoc/fit_rdoc.html">fit</a>
  
    <li><a href="../rdoc/function_rdoc.html">function</a>
  
    <li><a href="../rdoc/graph_rdoc.html">graph</a>
  
    <li><a href="../rdoc/hist_rdoc.html">hist</a>
  
    <li><a href="../rdoc/hist2d_rdoc.html">hist2d</a>
  
    <li><a href="../rdoc/hist3d_rdoc.html">hist3d</a>
  
    <li><a href="../rdoc/index_rdoc.html">index</a>
  
    <li><a href="../rdoc/integration_rdoc.html">integration</a>
  
    <li><a href="../rdoc/interp_rdoc.html">interp</a>
  
    <li><a href="../rdoc/intro_rdoc.html">intro</a>
  
    <li><a href="../rdoc/linalg_rdoc.html">linalg</a>
  
    <li><a href="../rdoc/linalg_complex_rdoc.html">linalg_complex</a>
  
    <li><a href="../rdoc/math_rdoc.html">math</a>
  
    <li><a href="../rdoc/matrix_rdoc.html">matrix</a>
  
    <li><a href="../rdoc/min_rdoc.html">min</a>
  
    <li><a href="../rdoc/monte_rdoc.html">monte</a>
  
    <li><a href="../rdoc/multimin_rdoc.html">multimin</a>
  
    <li><a href="../rdoc/multiroot_rdoc.html">multiroot</a>
  
    <li><a href="../rdoc/narray_rdoc.html">narray</a>
  
    <li><a href="../rdoc/ndlinear_rdoc.html">ndlinear</a>
  
    <li><a href="../rdoc/nonlinearfit_rdoc.html">nonlinearfit</a>
  
    <li><a href="../rdoc/ntuple_rdoc.html">ntuple</a>
  
    <li><a href="../rdoc/odeiv_rdoc.html">odeiv</a>
  
    <li><a href="../rdoc/perm_rdoc.html">perm</a>
  
    <li><a href="../rdoc/poly_rdoc.html">poly</a>
  
    <li><a href="../rdoc/qrng_rdoc.html">qrng</a>
  
    <li><a href="../rdoc/randist_rdoc.html">randist</a>
  
    <li><a href="../rdoc/ref_rdoc.html">ref</a>
  
    <li><a href="../rdoc/rng_rdoc.html">rng</a>
  
    <li><a href="../rdoc/roots_rdoc.html">roots</a>
  
    <li><a href="../rdoc/screenshot_rdoc.html">screenshot</a>
  
    <li><a href="../rdoc/sf_rdoc.html">sf</a>
  
    <li><a href="../rdoc/siman_rdoc.html">siman</a>
  
    <li><a href="../rdoc/sort_rdoc.html">sort</a>
  
    <li><a href="../rdoc/start_rdoc.html">start</a>
  
    <li><a href="../rdoc/stats_rdoc.html">stats</a>
  
    <li><a href="../rdoc/sum_rdoc.html">sum</a>
  
    <li><a href="../rdoc/tensor_rdoc.html">tensor</a>
  
    <li><a href="../rdoc/tut_rdoc.html">tut</a>
  
    <li><a href="../rdoc/use_rdoc.html">use</a>
  
    <li><a href="../rdoc/vector_rdoc.html">vector</a>
  
    <li><a href="../rdoc/vector_complex_rdoc.html">vector_complex</a>
  
    <li><a href="../rdoc/wavelet_rdoc.html">wavelet</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page rdoc/multiroot.rdoc">

<h1 id="label-Multidimensional+Root-Finding">Multidimensional Root-Finding<span><a href="#label-Multidimensional+Root-Finding">&para;</a> <a href="#documentation">&uarr;</a></span></h1>

<p>This chapter describes functions for multidimensional root-finding 
(solving nonlinear systems with n equations in n unknowns).  The library
provides low level components for a variety of iterative solvers  and
convergence tests. These can be combined by the user to achieve the 
desired solution, with full access to the intermediate steps of the
iteration.  Each class of methods uses the same framework, so that you can
switch between  solvers at runtime without needing to recompile your
program. Each instance of  a solver keeps track of its own state, allowing
the solvers to be used in  multi-threaded programs.</p>
<ol><li>
<p><a href="multiroot_rdoc.html#1">Overview</a></p>
</li><li>
<p><a href="multiroot_rdoc.html#2">Initializing the Solver</a></p>
</li><li>
<p><a href="multiroot_rdoc.html#3">Providing the function to solve</a></p>
</li><li>
<p><a href="multiroot_rdoc.html#4">Iteration</a></p>
</li><li>
<p><a href="multiroot_rdoc.html#5">Search Stopping Parameters</a></p>
</li><li>
<p><a href="multiroot_rdoc.html#6">Higher Level Interface</a></p>
</li><li>
<p><a href="multiroot_rdoc.html#7">Examples</a></p>
<ol><li>
<p><a href="multiroot_rdoc.html#7.1">FSolver</a></p>
</li><li>
<p><a href="multiroot_rdoc.html#7.2">FdfSolver</a></p>
</li></ol>
</li></ol>

<h2 id="label-+Overview"><a href="../index.html"name="1"></a> Overview<span><a href="#label-+Overview">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>The problem of multidimensional root finding requires the simultaneous 
solution of n equations, f_i, in n variables, x_i, In general there are no 
bracketing methods available for n dimensional systems, and no way of
knowing  whether any solutions exist. All algorithms proceed from an
initial guess  using a variant of the Newton iteration, where x, f are
vector quantities and  J is the Jacobian matrix J_{ij} = d f_i / d x_j.
Additional strategies can be  used to enlarge the region of convergence.
These include requiring a decrease  in the norm |f| on each step proposed
by Newton&#39;s method, or taking  steepest-descent steps in the direction
of the negative gradient of |f|.</p>

<p>Several root-finding algorithms are available within a single framework. 
The user provides a high-level driver for the algorithms, and the library 
provides the individual functions necessary for each of the steps. There
are  three main phases of the iteration. The steps are,</p>
<ul><li>
<p>initialize solver state, <code>s</code>, for algorithm <code>T</code></p>
</li><li>
<p>update <code>s</code> using the iteration <code>T</code></p>
</li><li>
<p>test <code>s</code> for convergence, and repeat iteration if necessary</p>
</li></ul>

<p>The evaluation of the Jacobian matrix can be problematic, either because 
programming the derivatives is intractable or because computation of the
n^2  terms of the matrix becomes too expensive. For these reasons the
algorithms  provided by the library are divided into two classes according
to whether  the derivatives are available or not.</p>

<p>The state for solvers with an analytic Jacobian matrix is held in a 
<code>GSL::MultiRoot::FdfSolver</code> object. The updating procedure
requires both  the function and its derivatives to be supplied by the user.</p>

<p>The state for solvers which do not use an analytic Jacobian matrix is held
in  a <code>GSL::MultiRoot::FSolver</code> object. The updating procedure
uses only  function evaluations (not derivatives). The algorithms estimate
the matrix J  or J^{-1} by approximate methods.</p>

<h2 id="label-+Initializing+the+Solver"><a href="../index.html"name="2"></a> Initializing the Solver<span><a href="#label-+Initializing+the+Solver">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>Two types of solvers are available. The solver itself depends only on the 
dimension of the problem and the algorithm and can be reused for different
problems. The <code>FdfSolver</code> requires derivatives of the function
to solve.</p>
<hr>
<ul><li>
<p>GSL::MultiRoot::FSolver.alloc(T, n)</p>

<p>This creates an instance of the <code>FSolver</code> class of type
<code>T</code>  for a system of <code>n</code> dimensions. The type is
given by a constant or a string,</p>
<ul><li>
<p>GSL::MultiRoot:FSolver::HYBRIDS, or “hybrids”</p>
</li><li>
<p>GSL::MultiRoot:FSolver::HYBRID, or “hybrid”</p>
</li><li>
<p>GSL::MultiRoot:FSolver::DNEWTON, or “dnewton”</p>
</li><li>
<p>GSL::MultiRoot:FSolver::BROYDEN, or “broyden”</p>
</li></ul>
</li></ul>
<hr>
<ul><li>
<p>GSL::MultiRoot::FdfSolver.alloc(T, n)</p>

<p>This creates an instance of the <code>FdfSolver</code> class of type
<code>T</code>  for a system of <code>n</code> dimensions. The type is
given by a constant,</p>
<ul><li>
<p>GSL::MultiRoot:FdfSolver::HYBRIDSJ, or “hybridsj”</p>
</li><li>
<p>GSL::MultiRoot:FdfSolver::HYBRIDJ, or “hybridj”,</p>
</li><li>
<p>GSL::MultiRoot:FdfSolver::NEWTON, or “newton”,</p>
</li><li>
<p>GSL::MultiRoot:FdfSolver::GNEWTON, or “gnewton</p>
</li></ul>
</li></ul>
<hr>
<ul><li>
<p>GSL::MultiRoot::FSolver#set(func, x)</p>

<p>This method sets, or resets, an existing solver <code>self</code>  to use
the function <code>func</code> and the initial guess <code>x</code>. Here
<code>x</code> is a <code>Vector</code>, and <code>func</code>  is a
<code>MultiRoot:Function</code> object.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::MultiRoot::FdfSolver#set(func_fdf, x)</p>

<p>This method sets, or resets, an existing solver <code>self</code>  to use
the function <code>func_fdf</code> and the initial guess <code>x</code>.
Here <code>x</code> is a <code>Vector</code>, and <code>func_fdf</code>  is
a <code>MultiRoot:Function_fdf</code> object.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::MultiRoot::FSolver#name</p>
</li><li>
<p>GSL::MultiRoot::FdfSolver#name</p>
</li></ul>

<h2 id="label-+Providing+the+function+to+solve"><a href="../index.html"name="3"></a> Providing the function to solve<span><a href="#label-+Providing+the+function+to+solve">&para;</a> <a href="#documentation">&uarr;</a></span></h2>
<hr>
<ul><li>
<p>GSL::MultiRoot:Function.alloc(proc, dim, params)</p>

<p>See example below:</p>

<pre class="ruby"><span class="ruby-comment"># x: vector, current guess</span>
<span class="ruby-comment"># params: a scalar or an array</span>
<span class="ruby-comment"># f: vector, function value</span>
<span class="ruby-identifier">proc</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span>, <span class="ruby-identifier">params</span>, <span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">a</span> = <span class="ruby-identifier">params</span>[<span class="ruby-value">0</span>]; <span class="ruby-identifier">b</span> = <span class="ruby-identifier">params</span>[<span class="ruby-value">1</span>]
  <span class="ruby-identifier">x0</span> = <span class="ruby-identifier">x</span>[<span class="ruby-value">0</span>]; <span class="ruby-identifier">x1</span> = <span class="ruby-identifier">x</span>[<span class="ruby-value">1</span>]
  <span class="ruby-identifier">f</span>[<span class="ruby-value">0</span>] = <span class="ruby-identifier">a</span><span class="ruby-operator">*</span>(<span class="ruby-value">1</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">x0</span>)
  <span class="ruby-identifier">f</span>[<span class="ruby-value">1</span>] = <span class="ruby-identifier">b</span><span class="ruby-operator">*</span>(<span class="ruby-identifier">x1</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">x0</span><span class="ruby-operator">*</span><span class="ruby-identifier">x0</span>)
}

<span class="ruby-identifier">params</span> = [<span class="ruby-value">1.0</span>, <span class="ruby-value">10.0</span>]
<span class="ruby-identifier">func</span> = <span class="ruby-constant">MultiRoot</span><span class="ruby-operator">::</span><span class="ruby-constant">Function</span>.<span class="ruby-identifier">alloc</span>(<span class="ruby-identifier">proc</span>, <span class="ruby-value">2</span>, <span class="ruby-identifier">params</span>)
<span class="ruby-identifier">fsolver</span> = <span class="ruby-constant">MultiRoot</span><span class="ruby-operator">::</span><span class="ruby-constant">FSolver</span>.<span class="ruby-identifier">alloc</span>(<span class="ruby-string">&quot;broyden&quot;</span>, <span class="ruby-value">2</span>)
<span class="ruby-identifier">x</span> = [<span class="ruby-value">-10</span>, <span class="ruby-value">-5</span>]    <span class="ruby-comment"># initial guess</span>
<span class="ruby-identifier">fsolver</span>.<span class="ruby-identifier">set</span>(<span class="ruby-identifier">func</span>, <span class="ruby-identifier">x</span>)
</pre>
</li></ul>
<hr>
<ul><li>
<p>GSL::MultiRoot:Function_fdf.alloc(proc, dim, params)</p>

<p>See the example below:</p>

<pre class="ruby"><span class="ruby-identifier">procf</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span>, <span class="ruby-identifier">params</span>, <span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">a</span> = <span class="ruby-identifier">params</span>[<span class="ruby-value">0</span>]; <span class="ruby-identifier">b</span> = <span class="ruby-identifier">params</span>[<span class="ruby-value">1</span>]
  <span class="ruby-identifier">x0</span> = <span class="ruby-identifier">x</span>[<span class="ruby-value">0</span>]; <span class="ruby-identifier">x1</span> = <span class="ruby-identifier">x</span>[<span class="ruby-value">1</span>]
  <span class="ruby-identifier">f</span>[<span class="ruby-value">0</span>] = <span class="ruby-identifier">a</span><span class="ruby-operator">*</span>(<span class="ruby-value">1</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">x0</span>)
  <span class="ruby-identifier">f</span>[<span class="ruby-value">1</span>] = <span class="ruby-identifier">b</span><span class="ruby-operator">*</span>(<span class="ruby-identifier">x1</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">x0</span><span class="ruby-operator">*</span><span class="ruby-identifier">x0</span>)
}

<span class="ruby-identifier">procdf</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span>, <span class="ruby-identifier">params</span>, <span class="ruby-identifier">jac</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">a</span> = <span class="ruby-identifier">params</span>[<span class="ruby-value">0</span>]; <span class="ruby-identifier">b</span> = <span class="ruby-identifier">params</span>[<span class="ruby-value">1</span>]
  <span class="ruby-identifier">jac</span>.<span class="ruby-identifier">set</span>(<span class="ruby-value">0</span>, <span class="ruby-value">0</span>, <span class="ruby-operator">-</span><span class="ruby-identifier">a</span>)
  <span class="ruby-identifier">jac</span>.<span class="ruby-identifier">set</span>(<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">0</span>)
  <span class="ruby-identifier">jac</span>.<span class="ruby-identifier">set</span>(<span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">-2</span><span class="ruby-operator">*</span><span class="ruby-identifier">b</span><span class="ruby-operator">*</span><span class="ruby-identifier">x</span>[<span class="ruby-value">0</span>])
  <span class="ruby-identifier">jac</span>.<span class="ruby-identifier">set</span>(<span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-identifier">b</span>)
}

<span class="ruby-identifier">params</span> = [<span class="ruby-value">1.0</span>, <span class="ruby-value">10.0</span>]
<span class="ruby-identifier">func_fdf</span> = <span class="ruby-constant">MultiRoot</span><span class="ruby-operator">::</span><span class="ruby-constant">Function_fdf</span>.<span class="ruby-identifier">alloc</span>(<span class="ruby-identifier">procf</span>, <span class="ruby-identifier">procdf</span>, <span class="ruby-identifier">n</span>, <span class="ruby-identifier">params</span>)

<span class="ruby-identifier">fdfsolver</span> = <span class="ruby-constant">MultiRoot</span><span class="ruby-operator">::</span><span class="ruby-constant">FdfSolver</span>.<span class="ruby-identifier">alloc</span>(<span class="ruby-string">&quot;gnewton&quot;</span>, <span class="ruby-identifier">n</span>)
<span class="ruby-identifier">x</span> = [<span class="ruby-value">-10.0</span>, <span class="ruby-value">-5.0</span>]
<span class="ruby-identifier">fdfsolver</span>.<span class="ruby-identifier">set</span>(<span class="ruby-identifier">func_fdf</span>, <span class="ruby-identifier">x</span>)
</pre>
</li></ul>

<h2 id="label-+Iteration"><a href="../index.html"name="4"></a> Iteration<span><a href="#label-+Iteration">&para;</a> <a href="#documentation">&uarr;</a></span></h2>
<hr>
<ul><li>
<p>GSL::MultiRoot::FSolver#interate</p>
</li><li>
<p>GSL::MultiRoot::FdfSolver#interate</p>

<p>These methods perform a single iteration of the solver <code>self</code>. 
If the iteration encounters an unexpected problem then an error code will 
be returned,</p>
<ul><li>
<p>GSL_EBADFUNC: the iteration encountered a singular point where the function
or its derivative evaluated to Inf or NaN.</p>
</li><li>
<p>GSL_ENOPROG: the iteration is not making any progress, preventing the 
algorithm from continuing.</p>
</li></ul>

<p>The solver maintains a current best estimate of the root at all times. 
This information can be accessed with the following auxiliary methods.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::MultiRoot::FSolver#root</p>
</li><li>
<p>GSL::MultiRoot::FdfSolver#root</p>

<p>These methods return the current estimate of the root (Vector) for the
solver <code>self</code>.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::MultiRoot::FSolver#f</p>
</li><li>
<p>GSL::MultiRoot::FdfSolver#f</p>

<p>These methds return the function value <code>f(x)</code> (Vector) at the
current estimate  of the root for the solver <code>self</code>.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::MultiRoot::FSolver#dx</p>
</li><li>
<p>GSL::MultiRoot::FdfSolver#dx</p>

<p>These method return the last step <code>dx</code> (Vector) taken by the
solver <code>self</code>.</p>
</li></ul>

<h2 id="label-+Search+Stopping+Parameters"><a href="../index.html"name="5"></a> Search Stopping Parameters<span><a href="#label-+Search+Stopping+Parameters">&para;</a> <a href="#documentation">&uarr;</a></span></h2>
<hr>
<ul><li>
<p>GSL::MultiRoot::FSolver#test_delta(epsabs, epsrel)</p>
</li><li>
<p>GSL::MultiRoot::FdfSolver#test_delta(epsabs, epsrel)</p>

<p>This method tests for the convergence of the sequence by comparing the last
step  <code>dx</code> with the absolute error <code>epsabs</code> and
relative error <code>epsrel</code>  to the current position <code>x</code>.
The test returns <code>GSL::SUCCESS</code> if the following condition is
achieved,</p>

<pre>|dx_i| &lt; epsabs + epsrel |x_i|</pre>

<p>for each component of <code>x</code> and returns <code>GSL::CONTINUE</code>
otherwise.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::MultiRoot::FSolver#test_residual(epsabs)</p>
</li><li>
<p>GSL::MultiRoot::FdfSolver#test_residual(epsabs)</p>

<p>This method tests the residual value <code>f</code> against the absolute
error  bound <code>epsabs</code>. The test returns
<code>GSL::SUCCESS</code> if the following  condition is achieved,</p>

<pre>sum_i |f_i| &lt; epsabs</pre>

<p>and returns <code>GSL::CONTINUE</code> otherwise. This criterion is
suitable for  situations where the precise location of the root,
<code>x</code>, is unimportant  provided a value can be found where the
residual is small enough.</p>
</li></ul>

<h2 id="label-+Higher+Level+Interface"><a href="../index.html"name="6"></a> Higher Level Interface<span><a href="#label-+Higher+Level+Interface">&para;</a> <a href="#documentation">&uarr;</a></span></h2>
<hr>
<ul><li>
<p>GSL::MultiRoot::Function#solve(x0, max_iter = 1000, eps = 1e-7, type =
“hybrids”)</p>
</li><li>
<p>GSL::MultiRoot::FSolver#solve(max_iter = 1000, eps = 1e-7)</p>
</li><li>
<p>GSL::MultiRoot::FSolver.solve(fsolver, max_iter = 1000, eps = 1e-7)</p>
</li></ul>

<p>See sample script <code>examples/multiroot/fsolver3.rb</code>.</p>

<h2 id="label-+Example"><a href="../index.html"name="7"></a> Example<span><a href="#label-+Example">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<h3 id="label-+FSolver"><a href="../index.html"name="7.1"></a> FSolver<span><a href="#label-+FSolver">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<pre class="ruby"><span class="ruby-identifier">proc</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span>, <span class="ruby-identifier">params</span>, <span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">a</span> = <span class="ruby-identifier">params</span>[<span class="ruby-value">0</span>];  <span class="ruby-identifier">b</span> = <span class="ruby-identifier">params</span>[<span class="ruby-value">1</span>]
  <span class="ruby-identifier">x0</span> = <span class="ruby-identifier">x</span>[<span class="ruby-value">0</span>];  <span class="ruby-identifier">x1</span> = <span class="ruby-identifier">x</span>[<span class="ruby-value">1</span>]
  <span class="ruby-identifier">f</span>[<span class="ruby-value">0</span>] = <span class="ruby-identifier">a</span><span class="ruby-operator">*</span>(<span class="ruby-value">1</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">x0</span>)
  <span class="ruby-identifier">f</span>[<span class="ruby-value">1</span>] = <span class="ruby-identifier">b</span><span class="ruby-operator">*</span>(<span class="ruby-identifier">x1</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">x0</span><span class="ruby-operator">*</span><span class="ruby-identifier">x0</span>)
}

<span class="ruby-identifier">params</span> = [<span class="ruby-value">1.0</span>, <span class="ruby-value">10.0</span>]
<span class="ruby-identifier">func</span> = <span class="ruby-constant">MultiRoot</span><span class="ruby-operator">::</span><span class="ruby-constant">Function</span>.<span class="ruby-identifier">alloc</span>(<span class="ruby-identifier">proc</span>, <span class="ruby-value">2</span>, <span class="ruby-identifier">params</span>)

<span class="ruby-identifier">fsolver</span> = <span class="ruby-constant">MultiRoot</span><span class="ruby-operator">::</span><span class="ruby-constant">FSolver</span>.<span class="ruby-identifier">alloc</span>(<span class="ruby-string">&quot;hybrid&quot;</span>, <span class="ruby-value">2</span>)
<span class="ruby-identifier">x</span> = [<span class="ruby-value">-10</span>, <span class="ruby-value">-5</span>]
<span class="ruby-identifier">fsolver</span>.<span class="ruby-identifier">set</span>(<span class="ruby-identifier">func</span>, <span class="ruby-identifier">x</span>)

<span class="ruby-identifier">iter</span> = <span class="ruby-value">0</span>
<span class="ruby-keyword">begin</span>
  <span class="ruby-identifier">iter</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
  <span class="ruby-identifier">status</span> = <span class="ruby-identifier">fsolver</span>.<span class="ruby-identifier">iterate</span>
  <span class="ruby-identifier">root</span> = <span class="ruby-identifier">fsolver</span>.<span class="ruby-identifier">root</span>
  <span class="ruby-identifier">f</span> = <span class="ruby-identifier">fsolver</span>.<span class="ruby-identifier">f</span>
  <span class="ruby-identifier">printf</span>(<span class="ruby-string">&quot;iter = %3u x = % .3f % .3f f(x) = % .3e % .3e\n&quot;</span>,
          <span class="ruby-identifier">iter</span>, <span class="ruby-identifier">root</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">root</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">f</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">f</span>[<span class="ruby-value">1</span>])
  <span class="ruby-identifier">status</span> = <span class="ruby-identifier">fsolver</span>.<span class="ruby-identifier">test_residual</span>(<span class="ruby-value">1e-7</span>)
<span class="ruby-keyword">end</span> <span class="ruby-keyword">while</span> <span class="ruby-identifier">status</span> <span class="ruby-operator">==</span> <span class="ruby-constant">GSL</span><span class="ruby-operator">::</span><span class="ruby-constant">CONTINUE</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">iter</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">1000</span>
</pre>

<h3 id="label-+FdfSolver"><a href="../index.html"name="7.2"></a> FdfSolver<span><a href="#label-+FdfSolver">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<pre class="ruby"><span class="ruby-identifier">n</span> = <span class="ruby-value">2</span>

<span class="ruby-identifier">procf</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span>, <span class="ruby-identifier">params</span>, <span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">a</span> = <span class="ruby-identifier">params</span>[<span class="ruby-value">0</span>]; <span class="ruby-identifier">b</span> = <span class="ruby-identifier">params</span>[<span class="ruby-value">1</span>]
  <span class="ruby-identifier">x0</span> = <span class="ruby-identifier">x</span>[<span class="ruby-value">0</span>]; <span class="ruby-identifier">x1</span> = <span class="ruby-identifier">x</span>[<span class="ruby-value">1</span>]
  <span class="ruby-identifier">f</span>[<span class="ruby-value">0</span>] = <span class="ruby-identifier">a</span><span class="ruby-operator">*</span>(<span class="ruby-value">1</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">x0</span>)
  <span class="ruby-identifier">f</span>[<span class="ruby-value">1</span>] = <span class="ruby-identifier">b</span><span class="ruby-operator">*</span>(<span class="ruby-identifier">x1</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">x0</span><span class="ruby-operator">*</span><span class="ruby-identifier">x0</span>)
}

<span class="ruby-identifier">procdf</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span>, <span class="ruby-identifier">params</span>, <span class="ruby-identifier">jac</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">a</span> = <span class="ruby-identifier">params</span>[<span class="ruby-value">0</span>]; <span class="ruby-identifier">b</span> = <span class="ruby-identifier">params</span>[<span class="ruby-value">1</span>]
  <span class="ruby-identifier">jac</span>.<span class="ruby-identifier">set</span>(<span class="ruby-value">0</span>, <span class="ruby-value">0</span>, <span class="ruby-operator">-</span><span class="ruby-identifier">a</span>)
  <span class="ruby-identifier">jac</span>.<span class="ruby-identifier">set</span>(<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">0</span>)
  <span class="ruby-identifier">jac</span>.<span class="ruby-identifier">set</span>(<span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">-2</span><span class="ruby-operator">*</span><span class="ruby-identifier">b</span><span class="ruby-operator">*</span><span class="ruby-identifier">x</span>[<span class="ruby-value">0</span>])
  <span class="ruby-identifier">jac</span>.<span class="ruby-identifier">set</span>(<span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-identifier">b</span>)
}

<span class="ruby-identifier">params</span> = [<span class="ruby-value">1.0</span>, <span class="ruby-value">10.0</span>]
<span class="ruby-identifier">f</span> = <span class="ruby-constant">MultiRoot</span><span class="ruby-operator">::</span><span class="ruby-constant">Function_fdf</span>.<span class="ruby-identifier">alloc</span>(<span class="ruby-identifier">procf</span>, <span class="ruby-identifier">procdf</span>, <span class="ruby-identifier">n</span>, <span class="ruby-identifier">params</span>)

<span class="ruby-identifier">fdfsolver</span> = <span class="ruby-constant">MultiRoot</span><span class="ruby-operator">::</span><span class="ruby-constant">FdfSolver</span>.<span class="ruby-identifier">alloc</span>(<span class="ruby-string">&quot;gnewton&quot;</span>, <span class="ruby-identifier">n</span>)

<span class="ruby-identifier">x</span> = [<span class="ruby-value">-10.0</span>, <span class="ruby-value">-5.0</span>]

<span class="ruby-identifier">fdfsolver</span>.<span class="ruby-identifier">set</span>(<span class="ruby-identifier">f</span>, <span class="ruby-identifier">x</span>)

<span class="ruby-identifier">iter</span> = <span class="ruby-value">0</span>
<span class="ruby-keyword">begin</span>
  <span class="ruby-identifier">iter</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
  <span class="ruby-identifier">status</span> = <span class="ruby-identifier">fdfsolver</span>.<span class="ruby-identifier">iterate</span>
  <span class="ruby-identifier">root</span> = <span class="ruby-identifier">fdfsolver</span>.<span class="ruby-identifier">root</span>
  <span class="ruby-identifier">f</span> = <span class="ruby-identifier">fdfsolver</span>.<span class="ruby-identifier">f</span>
  <span class="ruby-identifier">printf</span>(<span class="ruby-string">&quot;iter = %3u x = % .3f % .3f f(x) = % .3e % .3e\n&quot;</span>,
          <span class="ruby-identifier">iter</span>, <span class="ruby-identifier">root</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">root</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">f</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">f</span>[<span class="ruby-value">1</span>])
  <span class="ruby-identifier">status</span> = <span class="ruby-identifier">fdfsolver</span>.<span class="ruby-identifier">test_residual</span>(<span class="ruby-value">1e-7</span>)
<span class="ruby-keyword">end</span> <span class="ruby-keyword">while</span> <span class="ruby-identifier">status</span> <span class="ruby-operator">==</span> <span class="ruby-constant">GSL</span><span class="ruby-operator">::</span><span class="ruby-constant">CONTINUE</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">iter</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">1000</span>
</pre>

<p><a href="min_rdoc.html">prev</a> <a href="multimin_rdoc.html">next</a></p>

<p><a href="ref_rdoc.html">Reference index</a> <a href="../index.html">top</a></p>
</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://rdoc.rubyforge.org">RDoc</a> 4.1.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

