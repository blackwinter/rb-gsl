<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>fft - Ruby/GSL (v1.16.0)</title>

<link href="../fonts.css" rel="stylesheet">
<link href="../rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
</script>

<script src="../js/jquery.js"></script>
<script src="../js/navigation.js"></script>
<script src="../js/search_index.js"></script>
<script src="../js/search.js"></script>
<script src="../js/searcher.js"></script>
<script src="../js/darkfish.js"></script>


<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../table_of_contents.html#pages">Pages</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>

  <ul class="link-list" role="directory">
    <li><a href="#label-Fast+Fourier+Transforms">Fast Fourier Transforms</a>
    <li><a href="#label-+Mathematical+Definitions+"><a href="index.html"name="1"></a> Mathematical Definitions </a>
    <li><a href="#label-+Complex+data+FFTs"><a href="index.html"name="2"></a> Complex data FFTs</a>
    <li><a href="#label-+Overview+of+complex+data+FFTs"><a href="index.html"name="2.1"></a> Overview of complex data FFTs</a>
    <li><a href="#label-+Radix-2+FFT+routines+for+complex+data"><a href="index.html"name="2.2"></a> Radix-2 FFT routines for complex data</a>
    <li><a href="#label-+Example+of+complex+Radix-2+FFT"><a href="index.html"name="2.2.1"></a> Example of complex Radix-2 FFT</a>
    <li><a href="#label-+Mixed-radix+FFT+routines+for+complex+data"><a href="index.html"name="2.3"></a> Mixed-radix FFT routines for complex data</a>
    <li><a href="#label-+GSL%3A%3AFFT%3A%3AComplexWavetable+class"><a href="index.html"name="2.3.1"></a> GSL::FFT::ComplexWavetable class</a>
    <li><a href="#label-+GSL%3A%3AFFT%3A%3AComplexWorkspace+class"><a href="index.html"name="2.3.2"></a> GSL::FFT::ComplexWorkspace class</a>
    <li><a href="#label-+Methods+to+compute+transform"><a href="index.html"name="2.3.3"></a> Methods to compute transform</a>
    <li><a href="#label-+Example+to+use+the+mixed-radix+FFT+algorithm"><a href="index.html"name="2.3.4"></a> Example to use the mixed-radix FFT algorithm</a>
    <li><a href="#label-+Real+data+FFTs"><a href="index.html"name="3"></a> Real data FFTs</a>
    <li><a href="#label-+Overview+of+real+data+FFTs+"><a href="index.html"name="3.1"></a> Overview of real data FFTs </a>
    <li><a href="#label-+Radix-2+FFT+routines+for+real+data"><a href="index.html"name="3.2"></a> Radix-2 FFT routines for real data</a>
    <li><a href="#label-+Mixed-radix+FFT+routines+for+real+data"><a href="index.html"name="4"></a> Mixed-radix FFT routines for real data</a>
    <li><a href="#label-+Data+storage+scheme"><a href="index.html"name="4.1"></a> Data storage scheme</a>
    <li><a href="#label-+Wavetable+and+Workspace+classes"><a href="index.html"name="4.1.1"></a> Wavetable and Workspace classes</a>
    <li><a href="#label-+Methods+for+mixed-radix+real+FFTs"><a href="index.html"name="4.1.2"></a> Methods for mixed-radix real FFTs</a>
    <li><a href="#label-+Examples"><a href="index.html"name="5"></a> Examples</a>
    <li><a href="#label-+Example+1"><a href="index.html"name="5.1"></a> Example 1</a>
    <li><a href="#label-+Example+2"><a href="index.html"name="5.2"></a> Example 2</a>
  </ul>
</div>


  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="../rdoc/alf_rdoc.html">alf</a>
  
    <li><a href="../rdoc/blas_rdoc.html">blas</a>
  
    <li><a href="../rdoc/bspline_rdoc.html">bspline</a>
  
    <li><a href="../rdoc/changes_rdoc.html">changes</a>
  
    <li><a href="../rdoc/cheb_rdoc.html">cheb</a>
  
    <li><a href="../rdoc/cholesky_complex_rdoc.html">cholesky_complex</a>
  
    <li><a href="../rdoc/combi_rdoc.html">combi</a>
  
    <li><a href="../rdoc/complex_rdoc.html">complex</a>
  
    <li><a href="../rdoc/const_rdoc.html">const</a>
  
    <li><a href="../rdoc/dht_rdoc.html">dht</a>
  
    <li><a href="../rdoc/diff_rdoc.html">diff</a>
  
    <li><a href="../rdoc/ehandling_rdoc.html">ehandling</a>
  
    <li><a href="../rdoc/eigen_rdoc.html">eigen</a>
  
    <li><a href="../rdoc/fft_rdoc.html">fft</a>
  
    <li><a href="../rdoc/fit_rdoc.html">fit</a>
  
    <li><a href="../rdoc/function_rdoc.html">function</a>
  
    <li><a href="../rdoc/graph_rdoc.html">graph</a>
  
    <li><a href="../rdoc/hist_rdoc.html">hist</a>
  
    <li><a href="../rdoc/hist2d_rdoc.html">hist2d</a>
  
    <li><a href="../rdoc/hist3d_rdoc.html">hist3d</a>
  
    <li><a href="../rdoc/index_rdoc.html">index</a>
  
    <li><a href="../rdoc/integration_rdoc.html">integration</a>
  
    <li><a href="../rdoc/interp_rdoc.html">interp</a>
  
    <li><a href="../rdoc/intro_rdoc.html">intro</a>
  
    <li><a href="../rdoc/linalg_rdoc.html">linalg</a>
  
    <li><a href="../rdoc/linalg_complex_rdoc.html">linalg_complex</a>
  
    <li><a href="../rdoc/math_rdoc.html">math</a>
  
    <li><a href="../rdoc/matrix_rdoc.html">matrix</a>
  
    <li><a href="../rdoc/min_rdoc.html">min</a>
  
    <li><a href="../rdoc/monte_rdoc.html">monte</a>
  
    <li><a href="../rdoc/multimin_rdoc.html">multimin</a>
  
    <li><a href="../rdoc/multiroot_rdoc.html">multiroot</a>
  
    <li><a href="../rdoc/narray_rdoc.html">narray</a>
  
    <li><a href="../rdoc/ndlinear_rdoc.html">ndlinear</a>
  
    <li><a href="../rdoc/nonlinearfit_rdoc.html">nonlinearfit</a>
  
    <li><a href="../rdoc/ntuple_rdoc.html">ntuple</a>
  
    <li><a href="../rdoc/odeiv_rdoc.html">odeiv</a>
  
    <li><a href="../rdoc/perm_rdoc.html">perm</a>
  
    <li><a href="../rdoc/poly_rdoc.html">poly</a>
  
    <li><a href="../rdoc/qrng_rdoc.html">qrng</a>
  
    <li><a href="../rdoc/randist_rdoc.html">randist</a>
  
    <li><a href="../rdoc/ref_rdoc.html">ref</a>
  
    <li><a href="../rdoc/rng_rdoc.html">rng</a>
  
    <li><a href="../rdoc/roots_rdoc.html">roots</a>
  
    <li><a href="../rdoc/screenshot_rdoc.html">screenshot</a>
  
    <li><a href="../rdoc/sf_rdoc.html">sf</a>
  
    <li><a href="../rdoc/siman_rdoc.html">siman</a>
  
    <li><a href="../rdoc/sort_rdoc.html">sort</a>
  
    <li><a href="../rdoc/start_rdoc.html">start</a>
  
    <li><a href="../rdoc/stats_rdoc.html">stats</a>
  
    <li><a href="../rdoc/sum_rdoc.html">sum</a>
  
    <li><a href="../rdoc/tensor_rdoc.html">tensor</a>
  
    <li><a href="../rdoc/tut_rdoc.html">tut</a>
  
    <li><a href="../rdoc/use_rdoc.html">use</a>
  
    <li><a href="../rdoc/vector_rdoc.html">vector</a>
  
    <li><a href="../rdoc/vector_complex_rdoc.html">vector_complex</a>
  
    <li><a href="../rdoc/wavelet_rdoc.html">wavelet</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page rdoc/fft.rdoc">

<h1 id="label-Fast+Fourier+Transforms">Fast Fourier Transforms<span><a href="#label-Fast+Fourier+Transforms">&para;</a> <a href="#documentation">&uarr;</a></span></h1>

<p>Contents:</p>
<ol><li>
<p><a href="fft_rdoc.html#1">Mathematical Definitions</a></p>
</li><li>
<p><a href="fft_rdoc.html#2">Complex data FFTs</a></p>
<ol><li>
<p><a href="fft_rdoc.html#2.1">Overview of complex data FFTs</a></p>
</li><li>
<p><a href="fft_rdoc.html#2.2">Radix-2 FFT routines for complex data</a></p>
<ol><li>
<p><a href="fft_rdoc.html#2.2.1">Example of the complex Radix-2 FFT</a></p>
</li></ol>
</li><li>
<p><a href="fft_rdoc.html#2.3">Mixed-radix FFT routines for complex data</a></p>
<ol><li>
<p><a href="fft_rdoc.html#2.3.1">GSL::FFT::ComplexWavetable class</a></p>
</li><li>
<p><a href="fft_rdoc.html#2.3.2">GSL::FFT::ComplexWorkspace class</a></p>
</li><li>
<p><a href="fft_rdoc.html#2.3.3">Methods to compute the transform</a></p>
</li><li>
<p><a href="fft_rdoc.html#2.3.4">Example of the mixed-radix FFT</a></p>
</li></ol>
</li></ol>
</li><li>
<p><a href="fft_rdoc.html#3">Real data FFTs</a></p>
<ol><li>
<p><a href="fft_rdoc.html#3.1">Overview of real data FFTs</a></p>
</li><li>
<p><a href="fft_rdoc.html#3.2">Radix-2 FFT routines for real data</a></p>
</li><li>
<p><a href="fft_rdoc.html#3.3">Mixed-radix FFT routines for real data</a></p>
<ol><li>
<p><a href="fft_rdoc.html#3.3.1">Data storage scheme</a></p>
</li><li>
<p><a href="fft_rdoc.html#3.3.2">Wavetable and Workspace classes</a></p>
</li><li>
<p><a href="fft_rdoc.html#3.3.3">Methods for real FFTs</a></p>
</li><li>
<p><a href="fft_rdoc.html#3.3.4">Examples</a></p>
</li></ol>
</li></ol>
</li></ol>

<h2 id="label-+Mathematical+Definitions+"><a href="../index.html"name="1"></a> Mathematical Definitions <span><a href="#label-+Mathematical+Definitions+">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>Fast Fourier Transforms are efficient algorithms for calculating the
discrete  fourier transform (DFT),</p>

<p>The DFT usually arises as an approximation to the continuous fourier
transform  when functions are sampled at discrete intervals in space or
time.  The naive evaluation of the discrete fourier transform is a
matrix-vector  multiplication Wvec{z}. A general matrix-vector
multiplication takes O(N^2)  operations for N data-points. Fast fourier
transform algorithms use a  divide-and-conquer strategy to factorize the
matrix W into smaller  sub-matrices, corresponding to the integer factors
of the length N.  If N can be factorized into a product of integers f_1 f_2
… f_n then the  DFT can be computed in O(N sum f_i) operations. For a
radix-2 FFT this  gives an operation count of O(N log_2 N).</p>

<p>All the FFT functions offer three types of transform: forwards, inverse and
backwards, based on the same mathematical definitions. The definition of
the  forward fourier transform, x = FFT(z), is, and the definition of the
inverse  fourier transform, x = IFFT(z), is, The factor of 1/N makes this a
true  inverse. For example, a call to gsl_fft_complex_forward followed by a
call  to gsl_fft_complex_inverse should return the original data (within
numerical  errors).</p>

<p>In general there are two possible choices for the sign of the exponential 
in the transform/ inverse-transform pair. GSL follows the same convention
as FFTPACK, using a negative exponential for the forward transform.  The
advantage of this convention is that the inverse transform recreates  the
original function with simple fourier synthesis. Numerical Recipes uses 
the opposite convention, a positive exponential in the forward transform.</p>

<p>The backwards FFT is simply our terminology for an unscaled version of the 
inverse FFT, When the overall scale of the result is unimportant it is
often  convenient to use the backwards FFT instead of the inverse to save
unnecessary divisions.</p>

<h2 id="label-+Complex+data+FFTs"><a href="../index.html"name="2"></a> Complex data FFTs<span><a href="#label-+Complex+data+FFTs">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<h3 id="label-+Overview+of+complex+data+FFTs"><a href="../index.html"name="2.1"></a> Overview of complex data FFTs<span><a href="#label-+Overview+of+complex+data+FFTs">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>The complex data FFT routines are provided as instance methods of <a
href="vector_complex_rdoc.html">GSL::Vector::Complex</a>.</p>

<p>Here is a table which shows the layout of the array data, and the
correspondence  between the time-domain complex data z, and the
frequency-domain complex data x.</p>

<pre>index    z               x = FFT(z)

0        z(t = 0)        x(f = 0)
1        z(t = 1)        x(f = 1/(N Delta))
2        z(t = 2)        x(f = 2/(N Delta))
.        ........        ..................
N/2      z(t = N/2)      x(f = +1/(2 Delta),
                               -1/(2 Delta))
.        ........        ..................
N-3      z(t = N-3)      x(f = -3/(N Delta))
N-2      z(t = N-2)      x(f = -2/(N Delta))
N-1      z(t = N-1)      x(f = -1/(N Delta))</pre>

<p>When N is even the location N/2 contains the most positive and negative
frequencies +1/(2 Delta), -1/(2 Delta) which are equivalent. If N is odd
then general structure of the table above still applies, but N/2 does not
appear.</p>

<p><a href="vector_complex_rdoc.html">GSL::Vector::Complex</a> provides four
methods for shifting the frequency domain data between <strong>FFT
order</strong>, shown in the table above, and <strong>natural
order</strong>, which has the most negative freqeuncy component first, the
zero frequency component in the middle, and the most positive frequency
component last.</p>
<hr>
<ul><li>
<p>GSL::Vector::Complex#fftshift</p>
</li><li>
<p>GSL::Vector::Complex#fftshift!</p>

<p>Shifts the data of <code>self</code> from FFT order to natural order.  The
<code>#fftshift</code> method leaves <code>self</code> unmodified and
returns a new <code>GSL::Vector::Complex</code> object containing the
shifted data.  The <code>#fftshift!</code> method modifies
<code>self</code> in-place and returns <code>self</code>.  Note that
<code>#fftshift</code> and <code>#ifftshift</code> are equivalent for even
lengths, but not for odd lengths.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Vector::Complex#ifftshift</p>
</li><li>
<p>GSL::Vector::Complex#ifftshift!</p>

<p>Shifts the data of <code>self</code> from natural order to FFT order.  The
<code>#ifftshift</code> method leaves <code>self</code> unmodified and
returns a new <code>GSL::Vector::Complex</code> object containing the
shifted data.  The <code>#ifftshift!</code> method modifies
<code>self</code> in-place and returns <code>self</code>.  Note that
<code>#fftshift</code> and <code>#ifftshift</code> are equivalent for even
lengths, but not for odd lengths.</p>
</li></ul>

<h3 id="label-+Radix-2+FFT+routines+for+complex+data"><a href="../index.html"name="2.2"></a> Radix-2 FFT routines for complex data<span><a href="#label-+Radix-2+FFT+routines+for+complex+data">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>The radix-2 algorithms are simple and compact, although not necessarily the
most efficient. They use the Cooley-Tukey algorithm to compute complex 
FFTs for lengths which are a power of 2 – no additional storage is
required.  The corresponding self-sorting mixed-radix routines offer better
performance  at the expense of requiring additional working space.</p>

<p><strong>The FFT methods described below return FFTed data, and the input
vector is  not changed. Use methods with &#39;!&#39; as
<code>tranform!</code> for in-place transform.</strong></p>
<hr>
<ul><li>
<p>GSL::Vector::Complex#radix2_forward</p>
</li><li>
<p>GSL::Vector::Complex#radix2_backward</p>
</li><li>
<p>GSL::Vector::Complex#radix2_inverse</p>

<p>These functions compute forward, backward and inverse FFTs of the complex
vector using a radix-2 decimation-in-time algorithm.  The length of the
transform is restricted to powers of two.  These methods return the FFTed
data, and the input data is not changed.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Vector::Complex#radix2_transform(sign)</p>

<p>The sign argument can be either <code>GSL::FFT::FORWARD</code> or
<code>GSL::FFT::BACKWARD</code>.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Vector::Complex#radix2_dif_forward</p>
</li><li>
<p>GSL::Vector::Complex#radix2_dif_backward</p>
</li><li>
<p>GSL::Vector::Complex#radix2_dif_inverse</p>
</li><li>
<p>GSL::Vector::Complex#radix2_dif_transform</p>

<p>These are decimation-in-frequency versions of the radix-2 FFT functions.</p>
</li></ul>

<h4 id="label-+Example+of+complex+Radix-2+FFT"><a href="../index.html"name="2.2.1"></a> Example of complex Radix-2 FFT<span><a href="#label-+Example+of+complex+Radix-2+FFT">&para;</a> <a href="#documentation">&uarr;</a></span></h4>

<p>Here is an example program which computes the FFT of a short pulse in a 
sample of length  128. To make the resulting Fourier transform real the
pulse  is defined for equal positive and negative times (-10 … 10), where
the  negative times wrap around the end of the array.</p>

<pre>require(&quot;gsl&quot;)
include GSL

n = 128
data = Vector::Complex[n]

data[0] = 1.0
for i in 1..10 do
  data[i] = 1.0
  data[n-i] = 1.0
end

#for i in 0...n do
#  printf(&quot;%d %e %e\n&quot;, i, data[i].re, data[i].im)
#end

# You can choose whichever you like
#ffted = data.radix2_forward()
ffted = data.radix2_transform(FFT::FORWARD)
ffted /= Math::sqrt(n)
for i in 0...n do
  printf(&quot;%d %e %e\n&quot;, i, ffted[i].re, ffted[i].im)
end</pre>

<h3 id="label-+Mixed-radix+FFT+routines+for+complex+data"><a href="../index.html"name="2.3"></a> Mixed-radix FFT routines for complex data<span><a href="#label-+Mixed-radix+FFT+routines+for+complex+data">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<h4 id="label-+GSL%3A%3AFFT%3A%3AComplexWavetable+class"><a href="../index.html"name="2.3.1"></a> GSL::FFT::ComplexWavetable class<span><a href="#label-+GSL%3A%3AFFT%3A%3AComplexWavetable+class">&para;</a> <a href="#documentation">&uarr;</a></span></h4>
<hr>
<ul><li>
<p>GSL::FFT::ComplexWavetable.alloc(n)</p>

<p>This method prepares a trigonometric lookup table for a complex FFT of
length <code>n</code>. The length <code>n</code> is factorized into a
product of subtransforms, and the factors and their  trigonometric
coefficients are stored in the wavetable. The trigonometric coefficients
are  computed using direct calls to sin and cos, for accuracy. Recursion
relations could be used  to compute the lookup table faster, but if an
application performs many FFTs of the same  length then this computation is
a one-off overhead which does not affect the final  throughput.</p>

<p>The <code>Wavetable</code> object can be used repeatedly for any transform
of the same length. The table is not modified by calls to any of the other
FFT functions. The same wavetable  can be used for both forward and
backward (or inverse) transforms of a given length.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::FFT::ComplexWavetable#n</p>
</li><li>
<p>GSL::FFT::ComplexWavetable#nf</p>
</li><li>
<p>GSL::FFT::ComplexWavetable#factor</p>
</li></ul>

<h4 id="label-+GSL%3A%3AFFT%3A%3AComplexWorkspace+class"><a href="../index.html"name="2.3.2"></a> GSL::FFT::ComplexWorkspace class<span><a href="#label-+GSL%3A%3AFFT%3A%3AComplexWorkspace+class">&para;</a> <a href="#documentation">&uarr;</a></span></h4>
<hr>
<ul><li>
<p>GSL::FFT::ComplexWorkspace.alloc(n)</p>

<p>Creates a workspace for a complex transform of length <code>n</code>.</p>
</li></ul>

<h4 id="label-+Methods+to+compute+transform"><a href="../index.html"name="2.3.3"></a> Methods to compute transform<span><a href="#label-+Methods+to+compute+transform">&para;</a> <a href="#documentation">&uarr;</a></span></h4>

<p><strong>The FFT methods described below return FFTed data, and the input
vector is not changed. Use methods with &#39;!&#39; as
<code>tranform!</code> for in-place transform.</strong></p>
<hr>
<ul><li>
<p>GSL::Vector::Complex#forward(table, work)</p>
</li><li>
<p>GSL::Vector::Complex#forward(table)</p>
</li><li>
<p>GSL::Vector::Complex#forward(work)</p>
</li><li>
<p>GSL::Vector::Complex#forward()</p>
</li><li>
<p>GSL::Vector::Complex#backward(arguments same as forward)</p>
</li><li>
<p>GSL::Vector::Complex#inverse(arguments same as forward)</p>
</li><li>
<p>GSL::Vector::Complex#transform(arguments same as forward, sign)</p>

<p>These methods compute forward, backward and inverse FFTs of the complex
vector <code>self</code>, using a mixed radix decimation-in-frequency
algorithm. There is no restriction on the length.  Efficient modules are
provided for subtransforms of length 2, 3, 4, 5, 6 and 7.  Any remaining
factors are computed with a slow, O(n^2), general-n module.</p>

<p>The caller can supply a <code>table</code> containing the trigonometric
lookup tables and a workspace <code>work</code> (they are optional).</p>

<p>The sign argument for the method <code>transform</code> can be either
<code>GSL::FFT::FORWARD</code> or <code>GSL::FFT::BACKWARD</code>.</p>

<p>These methods return the FFTed data, and the input data is not changed.</p>
</li></ul>

<h4 id="label-+Example+to+use+the+mixed-radix+FFT+algorithm"><a href="../index.html"name="2.3.4"></a> Example to use the mixed-radix FFT algorithm<span><a href="#label-+Example+to+use+the+mixed-radix+FFT+algorithm">&para;</a> <a href="#documentation">&uarr;</a></span></h4>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;gsl&#39;</span>
<span class="ruby-identifier">include</span> <span class="ruby-constant">GSL</span>

<span class="ruby-identifier">n</span> = <span class="ruby-value">630</span>
<span class="ruby-identifier">data</span> = <span class="ruby-constant">FFT</span><span class="ruby-operator">::</span><span class="ruby-constant">Vector</span><span class="ruby-operator">::</span><span class="ruby-constant">Complex</span>[<span class="ruby-identifier">n</span>]

<span class="ruby-identifier">table</span> = <span class="ruby-constant">FFT</span><span class="ruby-operator">::</span><span class="ruby-constant">ComplexWavetable</span>.<span class="ruby-identifier">alloc</span>(<span class="ruby-identifier">n</span>)
<span class="ruby-identifier">space</span> = <span class="ruby-constant">FFT</span><span class="ruby-operator">::</span><span class="ruby-constant">ComplexWorkspace</span>.<span class="ruby-identifier">alloc</span>(<span class="ruby-identifier">n</span>)

<span class="ruby-identifier">data</span>[<span class="ruby-value">0</span>] = <span class="ruby-value">1.0</span>
<span class="ruby-keyword">for</span> <span class="ruby-identifier">i</span> <span class="ruby-keyword">in</span> <span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">data</span>[<span class="ruby-identifier">i</span>] = <span class="ruby-value">1.0</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">ffted</span> = <span class="ruby-identifier">data</span>.<span class="ruby-identifier">forward</span>(<span class="ruby-identifier">table</span>, <span class="ruby-identifier">space</span>)
<span class="ruby-comment">#ffted = data.forward()</span>
<span class="ruby-comment">#ffted = data.transform(FFT:Forward)</span>

<span class="ruby-identifier">ffted</span> <span class="ruby-operator">/=</span> <span class="ruby-constant">Math</span><span class="ruby-operator">::</span><span class="ruby-identifier">sqrt</span>(<span class="ruby-identifier">n</span>)
<span class="ruby-keyword">for</span> <span class="ruby-identifier">i</span> <span class="ruby-keyword">in</span> <span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-identifier">n</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">printf</span>(<span class="ruby-string">&quot;%d %e %e\n&quot;</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">data</span>[<span class="ruby-identifier">i</span>].<span class="ruby-identifier">re</span>, <span class="ruby-identifier">data</span>[<span class="ruby-identifier">i</span>].<span class="ruby-identifier">im</span>)
<span class="ruby-keyword">end</span>
</pre>

<h2 id="label-+Real+data+FFTs"><a href="../index.html"name="3"></a> Real data FFTs<span><a href="#label-+Real+data+FFTs">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<h3 id="label-+Overview+of+real+data+FFTs+"><a href="../index.html"name="3.1"></a> Overview of real data FFTs <span><a href="#label-+Overview+of+real+data+FFTs+">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>The functions for real data FFTs are provided as instance methods of <a
href="vector.class">GSL::Vector</a>.  While they are similar to those for
complex data, there is an important difference in the data storage layout
between forward and inverse transforms.  The Fourier transform of a real
sequence is not real. It is a complex sequence with a special symmetry.  A
sequence with this symmetry is called <code>conjugate-complex</code> or
<code>half-complex</code> and requires only as much storage as the original
real sequence instead of twice as much.</p>

<p>Forward transforms of real sequences produce half complex sequences of the
same length.  Backward and inverse transforms of half complex sequences
produce real sequences of the same length.  In both cases, the input and
output sequences are instances of <a
href="vector_rdoc.html">GSL::Vector</a>.</p>

<p>The precise storage arrangements of half complex seqeunces depend on the
algorithm, and are different for radix-2 and mixed-radix routines. The
radix-2 functions operate in-place, which constrains the locations where
each element can be stored. The restriction forces real and imaginary parts
to be stored far apart.  The mixed-radix algorithm does not have this
restriction, and it stores the real and imaginary parts of a given term in
neighboring locations (which is desirable for better locality of memory
accesses).  This means that a half complex sequence produces by a radix-2
forward transform <strong>cannot</strong> be recovered by a mixed-radix
inverse transform (and vice versa).</p>

<h3 id="label-+Radix-2+FFT+routines+for+real+data"><a href="../index.html"name="3.2"></a> Radix-2 FFT routines for real data<span><a href="#label-+Radix-2+FFT+routines+for+real+data">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>The routines for readix-2 real FFTs are provided as instance methods of <a
href="vector_rdoc.html">GSL::Vector</a>.</p>

<p><strong>The FFT methods described below return FFTed data, and the input
vector is not changed. Use methods with &#39;!&#39; as
<code>radix2_tranform!</code> for in-place transform.</strong></p>
<hr>
<ul><li>
<p>GSL::Vector#real_radix2_transform</p>
</li><li>
<p>GSL::Vector#radix2_transform</p>
</li><li>
<p>GSL::Vector#real_radix2_forward</p>
</li><li>
<p>GSL::Vector#radix2_forward</p>

<p>These methods compute a radix-2 FFT of the real vector <code>self</code>. 
The output is a half-complex sequence.  The arrangement of the half-complex
terms uses the following scheme: for k &lt; N/2 the real part of the k-th
term is stored in location k, and the corresponding imaginary part is
stored in location N-k. Terms with k &gt; N/2 can be reconstructed using
the symmetry z_k = z^*_{N-k}. The terms for k=0 and k=N/2 are both purely
real,  and count as a special case. Their real parts are stored in
locations 0 and N/2 respectively, while their imaginary parts which are
zero are not stored.</p>

<p>These methods return the FFTed data, and the input data is not changed.</p>

<p>The following table shows the correspondence between the output
<code>self</code>  and the equivalent results obtained by considering the
input data as a  complex sequence with zero imaginary part,</p>

<pre>complex[0].real    =    self[0] 
complex[0].imag    =    0 
complex[1].real    =    self[1] 
complex[1].imag    =    self[N-1]
    ...............         ................
complex[k].real    =    self[k]
complex[k].imag    =    self[N-k] 
    ...............         ................
complex[N/2].real  =    self[N/2]
complex[N/2].real  =    0
    ...............         ................
complex[k&#39;].real   =    self[k]        k&#39; = N - k
complex[k&#39;].imag   =   -self[N-k] 
    ...............         ................
complex[N-1].real  =    self[1]
complex[N-1].imag  =   -self[N-1]</pre>
</li></ul>
<hr>
<ul><li>
<p>GSL::Vector#halfcomplex_radix2_inverse</p>
</li><li>
<p>GSL::Vector#radix2_inverse</p>
</li><li>
<p>GSL::Vector#halfcomplex_radix2_backward</p>
</li><li>
<p>GSL::Vector#radix2_backward</p>

<p>These methods compute the inverse or backwards radix-2 FFT of the
half-complex sequence data stored according the output scheme used by
gsl_fft_real_radix2.  The result is a real array stored in natural order.</p>
</li></ul>

<h2 id="label-+Mixed-radix+FFT+routines+for+real+data"><a href="../index.html"name="4"></a> Mixed-radix FFT routines for real data<span><a href="#label-+Mixed-radix+FFT+routines+for+real+data">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>This section describes mixed-radix FFT algorithms for real data.  The
mixed-radix functions work for FFTs of any length. They are a 
reimplementation of the real-FFT routines in the Fortran FFTPACK library 
by Paul Swarztrauber.  The theory behind the algorithm is explained in the
article  <code>Fast Mixed-Radix Real Fourier Transforms</code> by Clive
Temperton.  The routines here use the same indexing scheme and basic
algorithms as  FFTPACK.</p>

<p>The functions use the FFTPACK storage convention for half-complex
sequences. In this convention the half-complex transform of a real sequence
is stored with frequencies in increasing order, starting at zero, with the
real and imaginary parts of each frequency in neighboring locations. When a
value is known to be real the imaginary part is not stored. The imaginary
part of the zero-frequency component is never stored. It is known to be
zero since the zero frequency component is simply the sum of the input data
(all real). For a sequence of even length the imaginary part of the
frequency n/2 is not stored either, since the symmetry z_k = z_{N-k}^*
implies that this is purely real too.</p>

<h3 id="label-+Data+storage+scheme"><a href="../index.html"name="4.1"></a> Data storage scheme<span><a href="#label-+Data+storage+scheme">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>The storage scheme is best shown by some examples.  The table below shows
the output for an odd-length sequence, n=5.  The two columns give the
correspondence between the 5 values in the  half-complex sequence computed
<code>real_transform</code>, <code>halfcomplex[]</code>  and the values
<code>complex[]</code> that would be returned if the same real input 
sequence were passed to <code>complex_backward</code> as a complex sequence
(with imaginary parts set to 0),</p>

<pre>complex[0].real  =  halfcomplex[0] 
complex[0].imag  =  0
complex[1].real  =  halfcomplex[1] 
complex[1].imag  =  halfcomplex[2]
complex[2].real  =  halfcomplex[3]
complex[2].imag  =  halfcomplex[4]
complex[3].real  =  halfcomplex[3]
complex[3].imag  = -halfcomplex[4]
complex[4].real  =  halfcomplex[1]
complex[4].imag  = -halfcomplex[2]</pre>

<p>The upper elements of the <code>complex</code> array,
<code>complex[3]</code> and <code>complex[4]</code> are filled in using the
symmetry condition. The imaginary part of  the zero-frequency term
<code>complex[0].imag</code> is known to be zero by the symmetry.</p>

<p>The next table shows the output for an even-length sequence,  n=5 In the
even case there are two values which are purely real,</p>

<pre>complex[0].real  =  halfcomplex[0]
complex[0].imag  =  0
complex[1].real  =  halfcomplex[1] 
complex[1].imag  =  halfcomplex[2] 
complex[2].real  =  halfcomplex[3] 
complex[2].imag  =  halfcomplex[4] 
complex[3].real  =  halfcomplex[5] 
complex[3].imag  =  0 
complex[4].real  =  halfcomplex[3] 
complex[4].imag  = -halfcomplex[4]
complex[5].real  =  halfcomplex[1] 
complex[5].imag  = -halfcomplex[2]</pre>

<p>The upper elements of the <code>complex</code> array,
<code>complex[4]</code>  and <code>complex[5]</code> are filled in using
the symmetry condition.  Both <code>complex[0].imag</code> and
<code>complex[3].imag</code> are known to be zero.</p>

<h4 id="label-+Wavetable+and+Workspace+classes"><a href="../index.html"name="4.1.1"></a> Wavetable and Workspace classes<span><a href="#label-+Wavetable+and+Workspace+classes">&para;</a> <a href="#documentation">&uarr;</a></span></h4>
<hr>
<ul><li>
<p>GSL::FFT::RealWavetable.alloc(n)</p>
</li><li>
<p>GSL::FFT::HalfComplexWavetable.alloc(n)</p>

<p>These methods create trigonometric lookup tables for an FFT of size
<code>n</code>  real elements. The length <code>n</code> is factorized into
a product of subtransforms,  and the factors and their trigonometric
coefficients are stored in the wavetable. The trigonometric coefficients
are computed using direct calls to sin and cos,  for accuracy. Recursion
relations could be used to compute the lookup table  faster, but if an
application performs many FFTs of the same length then  computing the
wavetable is a one-off overhead which does not affect the final 
throughput.</p>

<p>The wavetable structure can be used repeatedly for any transform of the
same  length. The table is not modified by calls to any of the other FFT
functions.  The appropriate type of wavetable must be used for forward real
or inverse half-complex transforms.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::FFT::RealWorkspace.alloc(n)</p>

<p>This method creates a workspace object for a real transform of length
<code>n</code>.  The same workspace can be used for both forward real and
inverse halfcomplex transforms.</p>
</li></ul>

<h4 id="label-+Methods+for+mixed-radix+real+FFTs"><a href="../index.html"name="4.1.2"></a> Methods for mixed-radix real FFTs<span><a href="#label-+Methods+for+mixed-radix+real+FFTs">&para;</a> <a href="#documentation">&uarr;</a></span></h4>

<p><strong>The FFT methods described below return FFTed data, and the input
vector is not changed. Use methods with &#39;!&#39; as
<code>real_tranform!</code> for in-place transform.</strong></p>
<hr>
<ul><li>
<p>GSL::Vector#real_transform(table, work)</p>
</li><li>
<p>GSL::Vector#halfcomplex_transform(table, work)</p>
</li><li>
<p>GSL::Vector#fft</p>

<p>These methods compute the FFT of <code>self</code>, a real or half-complex
array, using a mixed radix decimation-in-frequency algorithm.  For
<code>real_transform</code> <code>self</code> is an array of time-ordered
real data.  For <code>halfcomplex_transform</code> <code>self</code>
contains Fourier coefficients in the half-complex ordering described above.
There is no restriction on the length <code>n</code>.</p>

<p>Efficient modules are provided for subtransforms of length 2, 3, 4 and 5. 
Any remaining factors are computed with a slow, O(n^2), general-n module.</p>

<p>The caller can supply a <code>table</code> containing trigonometric lookup
tables  and a workspace <code>work</code> (optional).</p>

<p>These methods return the FFTed data, and the input data is not changed.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Vector#halfcomplex_inverse(table, work)</p>
</li><li>
<p>GSL::Vector#halfcomplex_backward(table, work)</p>
</li><li>
<p>GSL::Vector#ifft</p>
</li></ul>

<h2 id="label-+Examples"><a href="../index.html"name="5"></a> Examples<span><a href="#label-+Examples">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<h3 id="label-+Example+1"><a href="../index.html"name="5.1"></a> Example 1<span><a href="#label-+Example+1">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<pre>#!/usr/bin/env ruby
require(&quot;gsl&quot;)
include GSL

N = 2048
SAMPLING = 1000   # 1 kHz
TMAX = 1.0/SAMPLING*N
FREQ1 = 50
FREQ2 = 120
t = Vector.linspace(0, TMAX, N)
x = Sf::sin(2*M_PI*FREQ1*t) + Sf::sin(2*M_PI*FREQ2*t)
y = x.fft

y2 = y.subvector(1, N-2).to_complex2
mag = y2.abs
phase = y2.arg
f = Vector.linspace(0, SAMPLING/2, mag.size)
graph(f, mag, &quot;-C -g 3 -x 0 200 -X &#39;Frequency [Hz]&#39;&quot;)</pre>

<h3 id="label-+Example+2"><a href="../index.html"name="5.2"></a> Example 2<span><a href="#label-+Example+2">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<pre>#!/usr/bin/env ruby
require(&quot;gsl&quot;)
include GSL

n = 100
data = Vector.alloc(n)

for i in (n/3)...(2*n/3) do
  data[i] = 1.0
end

rtable = FFT::RealWavetable.alloc(n)
rwork = FFT::RealWorkspace.alloc(n)

#ffted = data.real_transform(rtable, rwork)
#ffted = data.real_transform(rtable)
#ffted = data.real_transform(rwork)
#ffted = data.real_transform()
ffted = data.fft

for i in 11...n do
  ffted[i] = 0.0
end

hctable = FFT::HalfComplexWavetable.alloc(n)

#data2 = ffted.halfcomplex_inverse(hctable, rwork)
#data2 = ffted.halfcomplex_inverse()
data2 = ffted.ifft

graph(nil, data, data2, &quot;-T X -C -g 3 -L &#39;Real-halfcomplex&#39; -x 0 #{data.size}&quot;)</pre>

<p><a href="eigen_rdoc.html">prev</a> <a href="wavelet_rdoc.html">next</a></p>

<p><a href="ref_rdoc.html">Reference index</a> <a href="../index.html">top</a></p>
</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://rdoc.rubyforge.org">RDoc</a> 4.1.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

