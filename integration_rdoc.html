<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>integration - Ruby/GSL (v1.16.0.3)</title>

<link href="./fonts.css" rel="stylesheet">
<link href="./rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script src="./js/jquery.js"></script>
<script src="./js/navigation.js"></script>
<script src="./js/search_index.js"></script>
<script src="./js/search.js"></script>
<script src="./js/searcher.js"></script>
<script src="./js/darkfish.js"></script>


<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>

  <ul class="link-list" role="directory">
    <li><a href="#label-Numerical+Integration">Numerical Integration</a>
    <li><a href="#label-Introduction">Introduction</a>
    <li><a href="#label-QNG+non-adaptive+Gauss-Kronrod+integration">QNG non-adaptive Gauss-Kronrod integration</a>
    <li><a href="#label-QAG+adaptive+integration">QAG adaptive integration</a>
    <li><a href="#label-Workspace+class">Workspace class</a>
    <li><a href="#label-Algorithms+which+require+the+workspace">Algorithms which require the workspace</a>
    <li><a href="#label-Methods">Methods</a>
    <li><a href="#label-QAGS+adaptive+integration+with+singularities">QAGS adaptive integration with singularities</a>
    <li><a href="#label-QAGP+adaptive+integration+with+known+singular+points">QAGP adaptive integration with known singular points</a>
    <li><a href="#label-QAGI+adaptive+integration+on+infinite+intervals">QAGI adaptive integration on infinite intervals</a>
    <li><a href="#label-QAWC+adaptive+integration+for+Cauchy+principal+values">QAWC adaptive integration for Cauchy principal values</a>
    <li><a href="#label-QAWS+adaptive+integration+for+singular+functions">QAWS adaptive integration for singular functions</a>
    <li><a href="#label-QAWO+adaptive+integration+for+oscillatory+functions">QAWO adaptive integration for oscillatory functions</a>
    <li><a href="#label-QAWF+adaptive+integration+for+Fourier+integrals">QAWF adaptive integration for Fourier integrals</a>
    <li><a href="#label-Gauss-Legendre+integration">Gauss-Legendre integration</a>
  </ul>
</div>


  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="./alf_rdoc.html">alf</a>
  
    <li><a href="./blas_rdoc.html">blas</a>
  
    <li><a href="./bspline_rdoc.html">bspline</a>
  
    <li><a href="./changes_rdoc.html">changes</a>
  
    <li><a href="./cheb_rdoc.html">cheb</a>
  
    <li><a href="./cholesky_complex_rdoc.html">cholesky_complex</a>
  
    <li><a href="./combi_rdoc.html">combi</a>
  
    <li><a href="./complex_rdoc.html">complex</a>
  
    <li><a href="./const_rdoc.html">const</a>
  
    <li><a href="./dht_rdoc.html">dht</a>
  
    <li><a href="./diff_rdoc.html">diff</a>
  
    <li><a href="./ehandling_rdoc.html">ehandling</a>
  
    <li><a href="./eigen_rdoc.html">eigen</a>
  
    <li><a href="./fft_rdoc.html">fft</a>
  
    <li><a href="./fit_rdoc.html">fit</a>
  
    <li><a href="./function_rdoc.html">function</a>
  
    <li><a href="./graph_rdoc.html">graph</a>
  
    <li><a href="./hist_rdoc.html">hist</a>
  
    <li><a href="./hist2d_rdoc.html">hist2d</a>
  
    <li><a href="./hist3d_rdoc.html">hist3d</a>
  
    <li><a href="./index_rdoc.html">index</a>
  
    <li><a href="./integration_rdoc.html">integration</a>
  
    <li><a href="./interp_rdoc.html">interp</a>
  
    <li><a href="./intro_rdoc.html">intro</a>
  
    <li><a href="./linalg_rdoc.html">linalg</a>
  
    <li><a href="./linalg_complex_rdoc.html">linalg_complex</a>
  
    <li><a href="./math_rdoc.html">math</a>
  
    <li><a href="./matrix_rdoc.html">matrix</a>
  
    <li><a href="./min_rdoc.html">min</a>
  
    <li><a href="./monte_rdoc.html">monte</a>
  
    <li><a href="./multimin_rdoc.html">multimin</a>
  
    <li><a href="./multiroot_rdoc.html">multiroot</a>
  
    <li><a href="./narray_rdoc.html">narray</a>
  
    <li><a href="./ndlinear_rdoc.html">ndlinear</a>
  
    <li><a href="./nonlinearfit_rdoc.html">nonlinearfit</a>
  
    <li><a href="./ntuple_rdoc.html">ntuple</a>
  
    <li><a href="./odeiv_rdoc.html">odeiv</a>
  
    <li><a href="./perm_rdoc.html">perm</a>
  
    <li><a href="./poly_rdoc.html">poly</a>
  
    <li><a href="./qrng_rdoc.html">qrng</a>
  
    <li><a href="./randist_rdoc.html">randist</a>
  
    <li><a href="./ref_rdoc.html">ref</a>
  
    <li><a href="./rng_rdoc.html">rng</a>
  
    <li><a href="./roots_rdoc.html">roots</a>
  
    <li><a href="./sf_rdoc.html">sf</a>
  
    <li><a href="./siman_rdoc.html">siman</a>
  
    <li><a href="./sort_rdoc.html">sort</a>
  
    <li><a href="./start_rdoc.html">start</a>
  
    <li><a href="./stats_rdoc.html">stats</a>
  
    <li><a href="./sum_rdoc.html">sum</a>
  
    <li><a href="./tensor_rdoc.html">tensor</a>
  
    <li><a href="./tut_rdoc.html">tut</a>
  
    <li><a href="./use_rdoc.html">use</a>
  
    <li><a href="./vector_rdoc.html">vector</a>
  
    <li><a href="./vector_complex_rdoc.html">vector_complex</a>
  
    <li><a href="./wavelet_rdoc.html">wavelet</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page integration.rdoc">

<h1 id="label-Numerical+Integration">Numerical Integration<span><a href="#label-Numerical+Integration">&para;</a> <a href="#documentation">&uarr;</a></span></h1>

<p>Contents:</p>
<ol><li>
<p><a href="integration_rdoc.html#label-Introduction">Introduction</a></p>
</li><li>
<p><a
href="integration_rdoc.html#label-QNG+non-adaptive+Gauss-Kronrod+integration">QNG
non-adaptive Gauss-Kronrod integration</a></p>
</li><li>
<p><a href="integration_rdoc.html#label-QAG+adaptive+integration">QAG adaptive
integration</a></p>
<ol><li>
<p><a
href="integration_rdoc.html#label-Workspace+class">GSL::Integration::Workspace
class</a></p>
</li><li>
<p><a href="integration_rdoc.html#label-Methods">Methods</a></p>
</li></ol>
</li><li>
<p><a
href="integration_rdoc.html#label-QAGS+adaptive+integration+with+singularities">QAGS
adaptive integration with singularities</a></p>
</li><li>
<p><a
href="integration_rdoc.html#label-QAGP+adaptive+integration+with+known+singular+points">QAGP
adaptive integration with known singular points</a></p>
</li><li>
<p><a
href="integration_rdoc.html#label-QAGI+adaptive+integration+on+infinite+intervals">QAGI
adaptive integration on infinite intervals</a></p>
</li><li>
<p><a
href="integration_rdoc.html#label-QAWC+adaptive+integration+for+Cauchy+principal+values">QAWC
adaptive integration for Cauchy principal values</a></p>
</li><li>
<p><a
href="integration_rdoc.html#label-QAWS+adaptive+integration+for+singular+functions">QAWS
adaptive integration for singular functions</a></p>
</li><li>
<p><a
href="integration_rdoc.html#label-QAWO+adaptive+integration+for+oscillatory+functions">QAWO
adaptive integration for oscillatory functions</a></p>
</li><li>
<p><a
href="integration_rdoc.html#label-QAWF+adaptive+integration+for+Fourier+integrals">QAWF
adaptive integration for Fourier integrals</a></p>
</li></ol>

<h2 id="label-Introduction">Introduction<span><a href="#label-Introduction">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>This section describes how to compute numerical integration of a function
in one dimension. In Ruby/GSL, all the GSL routines for numerical
integration is provided as methods of <a
href="function_rdoc.html">GSL::Function</a> objects. For example, a
<code>GSL::Function</code> object which represents the sine function
<code>sin(x)</code> can be expressed as</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">GSL</span><span class="ruby-operator">::</span><span class="ruby-constant">Function</span>.<span class="ruby-identifier">alloc</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">sin</span>(<span class="ruby-identifier">x</span>) }
</pre>

<p>To compute numerical integration of <code>sin(x)</code> over the range
<code>(a, b)</code>, one can use the methods <code>integrate_xxx</code> or
simply <code>xxx</code>, as</p>
<ul><li>
<p><code>f.integrate_xxx([a, b])</code>, or <code>f.xxx([a, b])</code></p>
</li><li>
<p><code>f.integrate_xxx(a, b)</code>, or <code>f.xxx(a, b)</code></p>
</li></ul>

<h2 id="label-QNG+non-adaptive+Gauss-Kronrod+integration">QNG non-adaptive Gauss-Kronrod integration<span><a href="#label-QNG+non-adaptive+Gauss-Kronrod+integration">&para;</a> <a href="#documentation">&uarr;</a></span></h2>
<hr>
<ul><li>
<p>GSL::Function#integration_qng([a, b], [epsabs = 0.0, epsrel = 1e-10])</p>
</li><li>
<p>GSL::Function#qng(…)</p>
</li><li>
<p>GSL::Integration::qng(…)</p>

<p>These methods apply the Gauss-Kronrod integration rules in succession until
an estimate of the integral of the reciever function (a
<code>GSL::Function</code> object) over <code>(a,b)</code> is achieved
within the desired absolute and relative error limits, <code>epsabs</code>
and <code>epsrel</code> (these are optional, the default values are 0,0 and
1e-10 respectively). These methods return an array of four elements
<code>[result, err, neval, status]</code>, those are the final
approximation of the integration, an estimate of the absolute error, the
number of function evaluation, and the status which is returned by the GSL
<code>integration_qng()</code> function.</p>
<ul><li>
<p>Ex: Integrate sin(x) over <code>x = 0 -- 2</code> with accuracies
<code>epsabs = 0, epsrel = 1.0e-7</code>.</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;gsl&#39;</span>

<span class="ruby-identifier">f</span> = <span class="ruby-constant">GSL</span><span class="ruby-operator">::</span><span class="ruby-constant">Function</span>.<span class="ruby-identifier">alloc</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">sin</span>(<span class="ruby-identifier">x</span>) }
<span class="ruby-identifier">ans</span> = <span class="ruby-identifier">f</span>.<span class="ruby-identifier">integration_qng</span>([<span class="ruby-value">0</span>, <span class="ruby-value">2</span>], [<span class="ruby-value">0</span>, <span class="ruby-value">1.0e-7</span>])   <span class="ruby-comment"># or shortly f.qng(...)</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ans</span>[<span class="ruby-value">0</span>]   <span class="ruby-operator">&lt;</span><span class="ruby-operator">-</span> <span class="ruby-identifier">result</span>
</pre>
</li></ul>

<p>For all the methods described in this section, the arguments <code>[epsabs,
epsrel]</code> are optional, and the default values are <code>[epsabs =
0.0, epsrel = 1e-10]</code>.</p>
</li></ul>

<h2 id="label-QAG+adaptive+integration">QAG adaptive integration<span><a href="#label-QAG+adaptive+integration">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>The QAG algorithm is a simple adaptive integration procedure. The
integration region is divided into subintervals, and on each iteration the
subinterval with the largest estimated error is bisected. This reduces the
overall error rapidly, as the subintervals become concentrated around local
difficulties in the integrand. These subintervals are managed by a
GSL::Integration::Workspace object, which handles the memory for the
subinterval ranges, results and error estimates.</p>

<h3 id="label-Workspace+class">Workspace class<span><a href="#label-Workspace+class">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Integration::Workspace.alloc(n = 1000)</p>

<p>This creates a workspace sufficient to hold n double precision intervals,
their integration results and error estimates.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Integration::Workspace#limit</p>
</li><li>
<p>GSL::Integration::Workspace#size</p>
</li></ul>

<h4 id="label-Algorithms+which+require+the+workspace">Algorithms which require the workspace<span><a href="#label-Algorithms+which+require+the+workspace">&para;</a> <a href="#documentation">&uarr;</a></span></h4>

<p>The algorithms described below require
<code>gsl_integration_workspace</code> struct in C. In Ruby/GSL, the
corresponding methods require a <code>GSL::Integration::Workspace</code>
object in their arguments. But it is also possible to use these methods
without workspace arguments: if it is not given, a workspace is
created/destroyed internally. Thus method calls are as</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">GSL</span><span class="ruby-operator">::</span><span class="ruby-constant">Function</span>.<span class="ruby-identifier">alloc</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-constant">Math</span><span class="ruby-operator">::</span><span class="ruby-identifier">sin</span>(<span class="ruby-identifier">x</span>)<span class="ruby-operator">/</span><span class="ruby-identifier">x</span> }
<span class="ruby-identifier">p</span> <span class="ruby-identifier">f</span>.<span class="ruby-identifier">qag</span>([<span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>])
</pre>

<p>or</p>

<pre>w = GSL::Integration::Workspace.alloc(limit)
p f.qag([a, b], w)</pre>

<p>Explicit uses of a <code>Workspace</code> object reduce C function calls
for memory allocations of workspace objects.</p>

<h3 id="label-Methods">Methods<span><a href="#label-Methods">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Function#integration_qag([a, b], key = GSL::Integration::GAUSS61)</p>
</li><li>
<p>GSL::Function#integration_qag([a, b], key, w)</p>
</li><li>
<p>GSL::Function#integration_qag([a, b], w)</p>
</li><li>
<p>GSL::Function#integration_qag([a, b], [epsabs, epsrel], key)</p>
</li><li>
<p>GSL::Function#integration_qag([a, b], [epsabs, epsrel], key, w)</p>
</li><li>
<p>GSL::Function#qag(…)</p>
</li><li>
<p>GSL::Integration::qag(…)</p>

<p>These methods apply an integration rule adaptively until an estimate of the
integral of the reciever function over <code>(a,b)</code> is achieved
within the desired absolute and relative error limits, <code>epsabs</code>
and <code>epsrel</code>. One can give a
<code>GSL::Integration::Workspace</code> object <code>w</code> with the
last argument (option: if not given, the workspace is internally allocated
and freed). The method returns an array with four elements <code>[result,
err, neval, status]</code>. The integration rule is determined by the value
of key, which should be chosen from the following symbolic names,</p>

<pre>GSL::Integration::GAUSS15  (key = 1)
GSL::Integration::GAUSS21  (key = 2)
GSL::Integration::GAUSS31  (key = 3)
GSL::Integration::GAUSS41  (key = 4)
GSL::Integration::GAUSS51  (key = 5)
GSL::Integration::GAUSS61  (key = 6)</pre>

<p>corresponding to the 15, 21, 31, 41, 51 and 61 point Gauss-Kronrod rules.
The higher-order rules give better accuracy for smooth functions, while
lower-order rules save time when the function contains local difficulties,
such as discontinuities.</p>
</li></ul>

<h2 id="label-QAGS+adaptive+integration+with+singularities">QAGS adaptive integration with singularities<span><a href="#label-QAGS+adaptive+integration+with+singularities">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>The presence of an integrable singularity in the integration region causes
an adaptive routine to concentrate new subintervals around the singularity.
As the subintervals decrease in size the successive approximations to the
integral converge in a limiting fashion. This approach to the limit can be
accelerated using an extrapolation procedure. The QAGS algorithm combines
adaptive bisection with the Wynn epsilon-algorithm to speed up the
integration of many types of integrable singularities.</p>
<hr>
<ul><li>
<p>GSL::Function#integration_qags([a, b], [epsabs = 0.0, epsrel = 1e-10],
limit)</p>
</li><li>
<p>GSL::Function#integration_qags([a, b], [epsabs, epsrel], limit, w)</p>
</li><li>
<p>GSL::Function#integration_qags([a, b], [epsabs, epsrel], w)</p>
</li><li>
<p>GSL::Function#qags(…)</p>
</li><li>
<p>GSL::Integration::qags(…)</p>

<p>These methods apply the Gauss-Kronrod 21-point integration rule adaptively
until an estimate of the integral over <code>(a,b)</code> is achieved
within the desired absolute and relative error limits, <code>epsabs</code>
and <code>epsrel</code>. The results are extrapolated using the
epsilon-algorithm, which accelerates the convergence of the integral in the
presence of discontinuities and integrable singularities. The maximum
number of subintervals is given by <code>limit</code>.</p>
<ul><li>
<p>ex:</p>

<pre class="ruby"><span class="ruby-identifier">proc</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span>{ <span class="ruby-operator">|</span><span class="ruby-identifier">x</span>, <span class="ruby-identifier">alpha</span><span class="ruby-operator">|</span>     <span class="ruby-comment"># integrant</span>
  <span class="ruby-identifier">log</span>(<span class="ruby-identifier">alpha</span><span class="ruby-operator">*</span><span class="ruby-identifier">x</span>)<span class="ruby-operator">/</span><span class="ruby-identifier">sqrt</span>(<span class="ruby-identifier">x</span>)
}

<span class="ruby-comment"># create the function, with the parameter alpha = 1.0</span>
<span class="ruby-identifier">f</span> = <span class="ruby-constant">GSL</span><span class="ruby-operator">::</span><span class="ruby-constant">Function</span>.<span class="ruby-identifier">alloc</span>(<span class="ruby-identifier">proc</span>, <span class="ruby-value">1.0</span>)

<span class="ruby-identifier">p</span> <span class="ruby-identifier">f</span>.<span class="ruby-identifier">integration_qags</span>(<span class="ruby-value">0</span>, <span class="ruby-value">1</span>)
</pre>
</li></ul>
</li></ul>

<h2 id="label-QAGP+adaptive+integration+with+known+singular+points">QAGP adaptive integration with known singular points<span><a href="#label-QAGP+adaptive+integration+with+known+singular+points">&para;</a> <a href="#documentation">&uarr;</a></span></h2>
<hr>
<ul><li>
<p>GSL::Function#integration_qagp(pts, [epsabs = 0.0, epsrel = 1e-10], limit =
1000, w)</p>
</li><li>
<p>GSL::Function#qagp(…)</p>
</li><li>
<p>GSL::Integration::qagp(…)</p>

<p>These methods apply the adaptive integration algorithm QAGS taking account
of the user-supplied locations of singular points. The array
<code>pts</code> (a Ruby array or a GSL::Vector object) should contain the
endpoints of the integration ranges defined by the integration region a nd
locations of the singularities. For example, to integrate over the region
<code>(a,b)</code> with break-points at x_1, x_2, x_3 (where a &lt; x_1
&lt; x_2 &lt; x_3 &lt; b) the following <code>pts</code> array should be
used</p>

<pre>pts[0] = a
pts[1] = x_1
pts[2] = x_2
pts[3] = x_3
pts[4] = b</pre>

<p>If you know the locations of the singular points in the integration region
then this routine will be faster than QAGS.</p>
<ul><li>
<p>ex:</p>

<pre class="ruby"><span class="ruby-identifier">f454</span> = <span class="ruby-constant">Function</span>.<span class="ruby-identifier">alloc</span>{ <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">x2</span> = <span class="ruby-identifier">x</span><span class="ruby-operator">*</span><span class="ruby-identifier">x</span>
  <span class="ruby-identifier">x3</span> = <span class="ruby-identifier">x2</span><span class="ruby-operator">*</span><span class="ruby-identifier">x</span>
  <span class="ruby-identifier">x3</span><span class="ruby-operator">*</span><span class="ruby-identifier">log</span>(((<span class="ruby-identifier">x2</span><span class="ruby-operator">-</span><span class="ruby-value">1</span>)<span class="ruby-operator">*</span>(<span class="ruby-identifier">x2</span><span class="ruby-operator">-</span><span class="ruby-value">2</span>)).<span class="ruby-identifier">abs</span>)
}
<span class="ruby-identifier">pts</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-identifier">sqrt</span>(<span class="ruby-value">2</span>), <span class="ruby-value">3</span>]     <span class="ruby-comment"># range: [0, 3], singular points: [1, sqrt(2)]</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">f454</span>.<span class="ruby-identifier">qagp</span>(<span class="ruby-identifier">pts</span>, <span class="ruby-value">0.0</span>, <span class="ruby-value">1e-3</span>)  <span class="ruby-comment"># &lt;---- [52.7408061167272, 0.000175570384826074, 20, 0]</span>
                             <span class="ruby-comment"># Expect: 61 log(2) + (77/4) log(7) - 27 = 52.7408061167272</span>
</pre>
</li></ul>
</li></ul>

<h2 id="label-QAGI+adaptive+integration+on+infinite+intervals">QAGI adaptive integration on infinite intervals<span><a href="#label-QAGI+adaptive+integration+on+infinite+intervals">&para;</a> <a href="#documentation">&uarr;</a></span></h2>
<hr>
<ul><li>
<p>GSL::Function#integration_qagi([epsabs = 0.0, epsrel = 1e-10], limit =
1000, w)</p>
</li><li>
<p>GSL::Function#qagi(…)</p>
</li><li>
<p>GSL::Integration::qagi(…)</p>

<p>These methods compute the integral of the function over the infinite
interval (-infty,+infty). The integral is mapped onto the interval (0,1]
using the transformation x = (1-t)/t. It is then integrated using the QAGS
algorithm. The normal 21-point Gauss-Kronrod rule of QAGS is replaced by a
15-point rule, because the transformation can generate an integrable
singularity at the origin. In this case a lower-order rule is more
efficient.</p>
<ul><li>
<p>ex</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">Function</span>.<span class="ruby-identifier">alloc</span>{ <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-constant">Math</span><span class="ruby-operator">::</span><span class="ruby-identifier">exp</span>(<span class="ruby-operator">-</span><span class="ruby-identifier">x</span><span class="ruby-operator">*</span><span class="ruby-identifier">x</span>) }
<span class="ruby-identifier">exact</span> = <span class="ruby-constant">Math</span><span class="ruby-operator">::</span><span class="ruby-identifier">sqrt</span>(<span class="ruby-constant">Math</span><span class="ruby-operator">::</span><span class="ruby-constant">PI</span>)

<span class="ruby-identifier">result</span>, = <span class="ruby-identifier">f</span>.<span class="ruby-identifier">qagi</span>
<span class="ruby-identifier">puts</span>(<span class="ruby-string">&quot;exp(-x*x), x = -infty --- +infty&quot;</span>)
<span class="ruby-identifier">printf</span>(<span class="ruby-string">&quot;exact  = %.18f\n&quot;</span>, <span class="ruby-identifier">exact</span>)
<span class="ruby-identifier">printf</span>(<span class="ruby-string">&quot;result = %.18f\n\n&quot;</span>, <span class="ruby-identifier">result</span>)
</pre>
</li></ul>
</li></ul>
<hr>
<ul><li>
<p>GSL::Function#integration_qagiu(a, epsabs = 0.0, epsrel = 1e-10, limit =
1000)</p>
</li><li>
<p>GSL::Function#integration_qagiu(a, epsabs = 0.0, epsrel = 1e-10, w)</p>
</li><li>
<p>GSL::Function#qagiu(…)</p>
</li><li>
<p>GSL::Integration::qagiu(…)</p>

<p>These methods compute the integral of the function over the semi-infinite
interval (a,+infty).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Function#integration_qagil(b, epsabs = 0.0, epsrel = 1e-10, limit =
1000)</p>
</li><li>
<p>GSL::Function#integration_qagil(b, epsabs = 0.0, epsrel = 1e-10, w)</p>
</li><li>
<p>GSL::Function#integration_qagil(b, [epsabs, epsrel], limit, w)</p>
</li><li>
<p>GSL::Function#qagil(…)</p>
</li><li>
<p>GSL::Integration::qagil(…)</p>

<p>These methods compute the integral of the function over the semi-infinite
interval (-infty,b).</p>
</li></ul>

<h2 id="label-QAWC+adaptive+integration+for+Cauchy+principal+values">QAWC adaptive integration for Cauchy principal values<span><a href="#label-QAWC+adaptive+integration+for+Cauchy+principal+values">&para;</a> <a href="#documentation">&uarr;</a></span></h2>
<hr>
<ul><li>
<p>GSL::Function#integration_qawc([a, b], c, [epsabs = 0.0, epsrel = 1e-10],
limit. 1000)</p>
</li><li>
<p>GSL::Function#qawc(…)</p>
</li><li>
<p>GSL::Function#qawc(…)</p>

<p>These methods compute the Cauchy principal value of the integral over
<code>(a,b)</code>, with a singularity at <code>c</code>. The adaptive
bisection algorithm of QAG is used, with modifications to ensure that
subdivisions do not occur at the singular point <code>x = c</code>. When a
subinterval contains the point <code>x = c</code> or is close to it then a
special 25-point modified Clenshaw-Curtis rule is used to control the
singularity. Further away from the singularity the algorithm uses an
ordinary 15-point Gauss-Kronrod integration rule.</p>
<ul><li>
<p>ex:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;gsl&#39;</span>
<span class="ruby-identifier">f459</span> = <span class="ruby-constant">Function</span>.<span class="ruby-identifier">alloc</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-value">1.0</span><span class="ruby-operator">/</span>(<span class="ruby-value">5.0</span><span class="ruby-operator">*</span><span class="ruby-identifier">x</span><span class="ruby-operator">*</span><span class="ruby-identifier">x</span><span class="ruby-operator">*</span><span class="ruby-identifier">x</span> <span class="ruby-operator">+</span> <span class="ruby-value">6.0</span>) }

<span class="ruby-identifier">p</span> <span class="ruby-identifier">f459</span>.<span class="ruby-identifier">qawc</span>([<span class="ruby-value">-1.0</span>, <span class="ruby-value">5.0</span>], <span class="ruby-value">0</span>, [<span class="ruby-value">0.0</span>, <span class="ruby-value">1e-3</span>]) <span class="ruby-comment"># Expect: log(125/631)/18</span>
</pre>
</li></ul>
</li></ul>

<h2 id="label-QAWS+adaptive+integration+for+singular+functions">QAWS adaptive integration for singular functions<span><a href="#label-QAWS+adaptive+integration+for+singular+functions">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>The QAWS algorithm is designed for integrands with algebraic-logarithmic
singularities at the end-points of an integration region. In order to work
efficiently the algorithm requires a precomputed table of Chebyshev
moments.</p>
<hr>
<ul><li>
<p>GSL::Function#integration_qaws([a, b], table, [epsabs = 0.0, epsrel =
1e-10], limit = 1000)</p>
</li><li>
<p>GSL::Function#integration_qaws(a, b, table, epsabs, epsrel, limit, w)</p>
</li><li>
<p>GSL::Function#qaws(…)</p>
</li><li>
<p>GSL::Integration::qaws(…)</p>

<p>These methods compute the integral of the function over the interval
<code>(a,b)</code> with the singular weight function</p>

<pre>(x-a)^alpha (b-x)^beta log^mu (x-a) log^nu (b-x)</pre>

<p>The parameters <code>[alpha, beta, mu, nu]</code> is given by a Ruby array
<code>table</code>, or by a <code>GSL::Integration::QAWS_Table</code>
object.</p>

<p>The adaptive bisection algorithm of QAG is used. When a subinterval
contains one of the endpoints then a special 25-point modified
Clenshaw-Curtis rule is used to control the singularities. For subintervals
which do not include the endpoints an ordinary 15-point Gauss-Kronrod
integration rule is used.</p>
<ul><li>
<p>ex1:</p>

<pre class="ruby"><span class="ruby-identifier">f458</span> = <span class="ruby-constant">Function</span>.<span class="ruby-identifier">alloc</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">zero?</span>
    <span class="ruby-identifier">val</span> = <span class="ruby-value">0.0</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">u</span> = <span class="ruby-identifier">log</span>(<span class="ruby-identifier">x</span>)
    <span class="ruby-identifier">v</span> = <span class="ruby-value">1.0</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">u</span><span class="ruby-operator">*</span><span class="ruby-identifier">u</span>
    <span class="ruby-identifier">val</span> = <span class="ruby-value">1.0</span><span class="ruby-operator">/</span>(<span class="ruby-identifier">v</span><span class="ruby-operator">*</span><span class="ruby-identifier">v</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">val</span>
}
<span class="ruby-identifier">table</span> = [<span class="ruby-value">0.0</span>, <span class="ruby-value">0.0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">0</span>]
<span class="ruby-identifier">p</span> <span class="ruby-identifier">f458</span>.<span class="ruby-identifier">qaws</span>([<span class="ruby-value">0.0</span>, <span class="ruby-value">1.0</span>], <span class="ruby-identifier">table</span>, [<span class="ruby-value">0.0</span>, <span class="ruby-value">1e-10</span>])  <span class="ruby-comment"># Expect: -0.1892752</span>
</pre>
</li><li>
<p>ex2:</p>

<pre>table = Integration::QAWS_Table.alloc(0.0, 0.0, 1, 0)
p f458.qaws([0.0, 1.0], table, [0.0, 1e-10])</pre>
</li></ul>
</li></ul>

<h2 id="label-QAWO+adaptive+integration+for+oscillatory+functions">QAWO adaptive integration for oscillatory functions<span><a href="#label-QAWO+adaptive+integration+for+oscillatory+functions">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>The QAWO algorithm is designed for integrands with an oscillatory factor,
sin(omega x) or cos(omega x). In order to work efficiently the algorithm
requires a table of Chebyshev moments.</p>
<hr>
<ul><li>
<p>GSL::Function#integration_qawo(a, [epsabs = 0.0, epsrel = 1e-10], limit =
1000, w, table, )</p>
</li><li>
<p>GSL::Function#qawo(…)</p>
</li><li>
<p>GSL::Integration::qawo(…)</p>

<p>This method uses an adaptive algorithm to compute the integral over
<code>[a,b]</code> with the weight function sin(omega x) or cos(omega x)
defined by the table <code>table</code>.</p>
<ul><li>
<p>ex1:</p>

<pre class="ruby"><span class="ruby-identifier">require</span>(<span class="ruby-string">&quot;gsl&quot;</span>)
<span class="ruby-identifier">f456</span> = <span class="ruby-constant">Function</span>.<span class="ruby-identifier">alloc</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">zero?</span>
    <span class="ruby-identifier">val</span> = <span class="ruby-value">0.0</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">val</span> = <span class="ruby-constant">Math</span><span class="ruby-operator">::</span><span class="ruby-identifier">log</span>(<span class="ruby-identifier">x</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">val</span>
}
<span class="ruby-identifier">table</span> = [<span class="ruby-value">10.0</span><span class="ruby-operator">*</span><span class="ruby-constant">Math</span><span class="ruby-operator">::</span><span class="ruby-constant">PI</span>, <span class="ruby-value">1.0</span>, <span class="ruby-constant">Integration</span><span class="ruby-operator">::</span><span class="ruby-constant">SINE</span>, <span class="ruby-value">1000</span>]
<span class="ruby-identifier">p</span> <span class="ruby-identifier">f456</span>.<span class="ruby-identifier">qawo</span>(<span class="ruby-value">0.0</span>, [<span class="ruby-value">0.0</span>, <span class="ruby-value">1e-10</span>], <span class="ruby-identifier">table</span>)
</pre>
</li><li>
<p>ex2:</p>

<pre>table = Integration::QAWO_Table.alloc(10.0*Math::PI, 1.0, Integration::SINE, 1000)
p f456.qawo(0.0, [0.0, 1e-10], table)</pre>
</li></ul>
</li></ul>

<h2 id="label-QAWF+adaptive+integration+for+Fourier+integrals">QAWF adaptive integration for Fourier integrals<span><a href="#label-QAWF+adaptive+integration+for+Fourier+integrals">&para;</a> <a href="#documentation">&uarr;</a></span></h2>
<hr>
<ul><li>
<p>GSL::Function#integration_qawf(a, epsabs = 1e-10, limit = 1000, w, wc,
table)</p>
</li><li>
<p>GSL::Function#integration_qawf(a, epsabs = 1e-10, limit = 1000, table)</p>
</li><li>
<p>GSL::Function#integration_qawf(a, epsabs = 1e-10, table)</p>
</li><li>
<p>GSL::Function#integration_qawf(a, table = 1000, table)</p>
</li><li>
<p>GSL::Function#integration_qawf(a, table)</p>
</li><li>
<p>GSL::Function#qawf(…)</p>
</li><li>
<p>GSL::Integration::qawf(…)</p>

<p>This method attempts to compute a Fourier integral of the function over the
semi-infinite interval [a,+infty).</p>

<pre>I = \int_a^{+infty} dx f(x) sin(omega x)
I = \int_a^{+infty} dx f(x) cos(omega x)</pre>

<p>The parameter omega is taken from the table <code>table</code> (the length
<code>L|</code> can take any value, since it is overridden by this function
to a value appropriate for the fourier integration).</p>
<ul><li>
<p>ex:</p>

<pre class="ruby"><span class="ruby-identifier">f457</span> = <span class="ruby-constant">Function</span>.<span class="ruby-identifier">alloc</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">zero?</span>
    <span class="ruby-identifier">val</span> = <span class="ruby-value">0.0</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">val</span> = <span class="ruby-value">1.0</span><span class="ruby-operator">/</span><span class="ruby-constant">Math</span><span class="ruby-operator">::</span><span class="ruby-identifier">sqrt</span>(<span class="ruby-identifier">x</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">val</span>
}
<span class="ruby-identifier">table</span> = [<span class="ruby-constant">PI</span><span class="ruby-operator">/</span><span class="ruby-value">2.0</span>, <span class="ruby-value">1.0</span>, <span class="ruby-constant">GSL</span><span class="ruby-operator">::</span><span class="ruby-constant">Integration</span><span class="ruby-operator">::</span><span class="ruby-constant">COSINE</span>, <span class="ruby-value">1000</span>]
<span class="ruby-identifier">p</span> <span class="ruby-identifier">f457</span>.<span class="ruby-identifier">qawf</span>(<span class="ruby-value">0.0</span>, <span class="ruby-value">1e-10</span>, <span class="ruby-identifier">table</span>)     <span class="ruby-comment">#  0.999999999927979, Expect 1</span>
</pre>
</li></ul>

<p>In other style:</p>

<pre>limit = 1000
table = Integration::QAWO_Table.alloc(PI/2.0, 1.0, GSL::Integration::COSINE, 1000)
w = Integration::Workspace.alloc          # default n is 1000
wc = Integration::Workspace.alloc(limit)

p f457.qawf(0.0, table)
p f457.qawf(0.0, 1e-10, table)
p f457.qawf(0.0, 1e-10, limit, table)
p f457.qawf(0.0, limit, table)
p f457.qawf(0.0, 1e-10, limit, w, wc, table)
p f457.qawf(0.0, w, wc, table)
p f457.qawf(0.0, limit, w, wc, table)
p f457.qawf(0.0, limit, w, table)       # Error
p f457.qawf(0.0, limit, wc, table)      # Error</pre>
</li></ul>

<h2 id="label-Gauss-Legendre+integration">Gauss-Legendre integration<span><a href="#label-Gauss-Legendre+integration">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>(GSL-1.14) The fixed-order Gauss-Legendre integration routines are provided
for fast integration of smooth functions with known polynomial order. The
n-point Gauss-Legendre rule is exact for polynomials of order 2*n-1 or
less. For example, these rules are useful when integrating basis functions
to form mass matrices for the Galerkin method. Unlike other numerical
integration routines within the library, these routines do not accept
absolute or relative error bounds.</p>
<hr>
<ul><li>
<p>GSL::Integration::Glfixed_table.alloc(n)</p>

<p>Determines the Gauss-Legendre abscissae and weights necessary for an
<code>n</code>-point fixed order integration scheme. If possible, high
precision precomputed coefficients are used. If precomputed weights are not
available, lower precision coefficients are computed on the fly.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Function#glfixed(a, b, t)</p>

<p>Applies the Gauss-Legendre integration rule contained in table
<code>t</code> and returns the result.</p>
</li></ul>

<p><a href="wavelet_rdoc.html">prev</a> <a href="rng_rdoc.html">next</a></p>

<p><a href="ref_rdoc.html">Reference index</a> <a href="index.html">top</a></p>
</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://rdoc.rubyforge.org">RDoc</a> 4.1.2.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

