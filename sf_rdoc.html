<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>sf - Ruby/GSL (v1.16.0.2)</title>

<link href="./fonts.css" rel="stylesheet">
<link href="./rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script src="./js/jquery.js"></script>
<script src="./js/navigation.js"></script>
<script src="./js/search_index.js"></script>
<script src="./js/search.js"></script>
<script src="./js/searcher.js"></script>
<script src="./js/darkfish.js"></script>


<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>

  <ul class="link-list" role="directory">
    <li><a href="#label-Special+Functions">Special Functions</a>
    <li><a href="#label-Contents%3A">Contents:</a>
    <li><a href="#label-Usage">Usage</a>
    <li><a href="#label-Result+class"><code>Result</code> class</a>
    <li><a href="#label-Result+instance+methods"><code>Result</code> instance methods</a>
    <li><a href="#label-Modes">Modes</a>
    <li><a href="#label-Airy+Functions+and+Derivatives">Airy Functions and Derivatives</a>
    <li><a href="#label-Derivatives+of+Airy+Functions">Derivatives of Airy Functions</a>
    <li><a href="#label-Zeros+of+Airy+Functions">Zeros of Airy Functions</a>
    <li><a href="#label-Zeros+of+Derivatives+of+Airy+Functions">Zeros of Derivatives of Airy Functions</a>
    <li><a href="#label-Bessel+Functions">Bessel Functions</a>
    <li><a href="#label-Regular+Cylindrical+Bessel+Functions">Regular Cylindrical Bessel Functions</a>
    <li><a href="#label-Irregular+Cylindrical+Bessel+Functions">Irregular Cylindrical Bessel Functions</a>
    <li><a href="#label-Regular+Modified+Cylindrical+Bessel+Functions">Regular Modified Cylindrical Bessel Functions</a>
    <li><a href="#label-Irregular+Modified+Cylindrical+Bessel+Functions">Irregular Modified Cylindrical Bessel Functions</a>
    <li><a href="#label-Regular+Spherical+Bessel+Functions">Regular Spherical Bessel Functions</a>
    <li><a href="#label-Irregular+Spherical+Bessel+Functions">Irregular Spherical Bessel Functions</a>
    <li><a href="#label-Regular+Modified+Spherical+Bessel+Functions">Regular Modified Spherical Bessel Functions</a>
    <li><a href="#label-Irregular+Modified+Spherical+Bessel+Functions">Irregular Modified Spherical Bessel Functions</a>
    <li><a href="#label-Regular+Bessel+Function+-+Fractional+Order">Regular Bessel Function - Fractional Order</a>
    <li><a href="#label-Irregular+Bessel+Functions+-+Fractional+Order">Irregular Bessel Functions - Fractional Order</a>
    <li><a href="#label-Regular+Modified+Bessel+Functions+-+Fractional+Order">Regular Modified Bessel Functions - Fractional Order</a>
    <li><a href="#label-Irregular+Modified+Bessel+Functions+-+Fractional+Order">Irregular Modified Bessel Functions - Fractional Order</a>
    <li><a href="#label-Zeros+of+Regular+Bessel+Functions">Zeros of Regular Bessel Functions</a>
    <li><a href="#label-Clausen+Functions">Clausen Functions</a>
    <li><a href="#label-Coulomb+Functions">Coulomb Functions</a>
    <li><a href="#label-Coulomb+Wave+Functions">Coulomb Wave Functions</a>
    <li><a href="#label-Coulomb+Wave+Function+Normalization+Constant">Coulomb Wave Function Normalization Constant</a>
    <li><a href="#label-Coupling+Coefficients">Coupling Coefficients</a>
    <li><a href="#label-Dawson+Function">Dawson Function</a>
    <li><a href="#label-Debye+Functions">Debye Functions</a>
    <li><a href="#label-Dilogarithm">Dilogarithm</a>
    <li><a href="#label-Real+Argument">Real Argument</a>
    <li><a href="#label-Complex+Argument">Complex Argument</a>
    <li><a href="#label-Elementary+Operations">Elementary Operations</a>
    <li><a href="#label-Elliptic+Integrals">Elliptic Integrals</a>
    <li><a href="#label-Legendre+Form+of+Complete+Elliptic+Integrals">Legendre Form of Complete Elliptic Integrals</a>
    <li><a href="#label-Legendre+Form+of+Incomplete+Elliptic+Integrals">Legendre Form of Incomplete Elliptic Integrals</a>
    <li><a href="#label-Carlson+Forms">Carlson Forms</a>
    <li><a href="#label-Elliptic+Functions+%28Jacobi%29">Elliptic Functions (Jacobi)</a>
    <li><a href="#label-Error+Functions">Error Functions</a>
    <li><a href="#label-Probability+functions">Probability functions</a>
    <li><a href="#label-Exponential+Functions">Exponential Functions</a>
    <li><a href="#label-Relative+Exponential+Functions">Relative Exponential Functions</a>
    <li><a href="#label-Exponentiation+With+Error+Estimate">Exponentiation With Error Estimate</a>
    <li><a href="#label-Exponential+Integrals">Exponential Integrals</a>
    <li><a href="#label-Exponential+Integral">Exponential Integral</a>
    <li><a href="#label-Ei%28x%29">Ei(x)</a>
    <li><a href="#label-Hyperbolic+Integrals">Hyperbolic Integrals</a>
    <li><a href="#label-Ei_3%28x%29">Ei_3(x)</a>
    <li><a href="#label-Trigonometric+Integrals">Trigonometric Integrals</a>
    <li><a href="#label-Arctangent+Integral">Arctangent Integral</a>
    <li><a href="#label-Fermi-Dirac+Functions">Fermi-Dirac Functions</a>
    <li><a href="#label-Complete+Fermi-Dirac+Integrals">Complete Fermi-Dirac Integrals</a>
    <li><a href="#label-Incomplete+Fermi-Dirac+Integrals">Incomplete Fermi-Dirac Integrals</a>
    <li><a href="#label-Gamma+Function">Gamma Function</a>
    <li><a href="#label-Gegenbauer+Functions">Gegenbauer Functions</a>
    <li><a href="#label-Hypergeometric+Functions">Hypergeometric Functions</a>
    <li><a href="#label-Laguerre+Functions">Laguerre Functions</a>
    <li><a href="#label-Lambert+W+Functions">Lambert W Functions</a>
    <li><a href="#label-Legendre+Functions+and+Spherical+Harmonics">Legendre Functions and Spherical Harmonics</a>
    <li><a href="#label-Legendre+Polynomials">Legendre Polynomials</a>
    <li><a href="#label-Associated+Legendre+Polynomials+and+Spherical+Harmonics">Associated Legendre Polynomials and Spherical Harmonics</a>
    <li><a href="#label-Conical+Functions">Conical Functions</a>
    <li><a href="#label-Radial+Functions+for+Hyperbolic+Space">Radial Functions for Hyperbolic Space</a>
    <li><a href="#label-Logarithm+and+Related+Functions">Logarithm and Related Functions</a>
    <li><a href="#label-Mathieu+functions">Mathieu functions</a>
    <li><a href="#label-Mathieu+Function+Workspace">Mathieu Function Workspace</a>
    <li><a href="#label-Mathieu+Function+Characteristic+Values">Mathieu Function Characteristic Values</a>
    <li><a href="#label-Angular+Mathieu+Functions">Angular Mathieu Functions</a>
    <li><a href="#label-Radial+Mathieu+Functions">Radial Mathieu Functions</a>
    <li><a href="#label-Power+Functions">Power Functions</a>
    <li><a href="#label-Psi+%28Digamma%29+Function">Psi (Digamma) Function</a>
    <li><a href="#label-Digamma+Function">Digamma Function</a>
    <li><a href="#label-Trigamma+Function">Trigamma Function</a>
    <li><a href="#label-Polygamma+Function">Polygamma Function</a>
    <li><a href="#label-Synchrotron+Functions">Synchrotron Functions</a>
    <li><a href="#label-Transport+Functions">Transport Functions</a>
    <li><a href="#label-Trigonometric+Functions">Trigonometric Functions</a>
    <li><a href="#label-Circular+Trigonometric+Functions">Circular Trigonometric Functions</a>
    <li><a href="#label-Trigonometric+Functions+for+Complex+Arguments">Trigonometric Functions for Complex Arguments</a>
    <li><a href="#label-Hyperbolic+Trigonometric+Functions">Hyperbolic Trigonometric Functions</a>
    <li><a href="#label-Conversion+Functions">Conversion Functions</a>
    <li><a href="#label-Restriction+Functions">Restriction Functions</a>
    <li><a href="#label-Trigonometric+Functions+With+Error+Estimates">Trigonometric Functions With Error Estimates</a>
    <li><a href="#label-Zeta+Functions">Zeta Functions</a>
    <li><a href="#label-Riemann+Zeta+Function">Riemann Zeta Function</a>
    <li><a href="#label-Riemann+Zeta+Function+Minus+One">Riemann Zeta Function Minus One</a>
    <li><a href="#label-Hurwitz+Zeta+Function">Hurwitz Zeta Function</a>
    <li><a href="#label-Eta+Function">Eta Function</a>
  </ul>
</div>


  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="./alf_rdoc.html">alf</a>
  
    <li><a href="./blas_rdoc.html">blas</a>
  
    <li><a href="./bspline_rdoc.html">bspline</a>
  
    <li><a href="./changes_rdoc.html">changes</a>
  
    <li><a href="./cheb_rdoc.html">cheb</a>
  
    <li><a href="./cholesky_complex_rdoc.html">cholesky_complex</a>
  
    <li><a href="./combi_rdoc.html">combi</a>
  
    <li><a href="./complex_rdoc.html">complex</a>
  
    <li><a href="./const_rdoc.html">const</a>
  
    <li><a href="./dht_rdoc.html">dht</a>
  
    <li><a href="./diff_rdoc.html">diff</a>
  
    <li><a href="./ehandling_rdoc.html">ehandling</a>
  
    <li><a href="./eigen_rdoc.html">eigen</a>
  
    <li><a href="./fft_rdoc.html">fft</a>
  
    <li><a href="./fit_rdoc.html">fit</a>
  
    <li><a href="./function_rdoc.html">function</a>
  
    <li><a href="./graph_rdoc.html">graph</a>
  
    <li><a href="./hist_rdoc.html">hist</a>
  
    <li><a href="./hist2d_rdoc.html">hist2d</a>
  
    <li><a href="./hist3d_rdoc.html">hist3d</a>
  
    <li><a href="./index_rdoc.html">index</a>
  
    <li><a href="./integration_rdoc.html">integration</a>
  
    <li><a href="./interp_rdoc.html">interp</a>
  
    <li><a href="./intro_rdoc.html">intro</a>
  
    <li><a href="./linalg_rdoc.html">linalg</a>
  
    <li><a href="./linalg_complex_rdoc.html">linalg_complex</a>
  
    <li><a href="./math_rdoc.html">math</a>
  
    <li><a href="./matrix_rdoc.html">matrix</a>
  
    <li><a href="./min_rdoc.html">min</a>
  
    <li><a href="./monte_rdoc.html">monte</a>
  
    <li><a href="./multimin_rdoc.html">multimin</a>
  
    <li><a href="./multiroot_rdoc.html">multiroot</a>
  
    <li><a href="./narray_rdoc.html">narray</a>
  
    <li><a href="./ndlinear_rdoc.html">ndlinear</a>
  
    <li><a href="./nonlinearfit_rdoc.html">nonlinearfit</a>
  
    <li><a href="./ntuple_rdoc.html">ntuple</a>
  
    <li><a href="./odeiv_rdoc.html">odeiv</a>
  
    <li><a href="./perm_rdoc.html">perm</a>
  
    <li><a href="./poly_rdoc.html">poly</a>
  
    <li><a href="./qrng_rdoc.html">qrng</a>
  
    <li><a href="./randist_rdoc.html">randist</a>
  
    <li><a href="./ref_rdoc.html">ref</a>
  
    <li><a href="./rng_rdoc.html">rng</a>
  
    <li><a href="./roots_rdoc.html">roots</a>
  
    <li><a href="./sf_rdoc.html">sf</a>
  
    <li><a href="./siman_rdoc.html">siman</a>
  
    <li><a href="./sort_rdoc.html">sort</a>
  
    <li><a href="./start_rdoc.html">start</a>
  
    <li><a href="./stats_rdoc.html">stats</a>
  
    <li><a href="./sum_rdoc.html">sum</a>
  
    <li><a href="./tensor_rdoc.html">tensor</a>
  
    <li><a href="./tut_rdoc.html">tut</a>
  
    <li><a href="./use_rdoc.html">use</a>
  
    <li><a href="./vector_rdoc.html">vector</a>
  
    <li><a href="./vector_complex_rdoc.html">vector_complex</a>
  
    <li><a href="./wavelet_rdoc.html">wavelet</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page sf.rdoc">

<h1 id="label-Special+Functions">Special Functions<span><a href="#label-Special+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h1>

<h3 id="label-Contents%3A">Contents:<span><a href="#label-Contents%3A">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<ol><li>
<p><a href="sf_rdoc.html#label-Usage">Usage:</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Result+class">GSL::Sf::Result class</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Modes">Modes</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Airy+Functions+and+Derivatives">Airy
functions</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Bessel+Functions">Bessel functins</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Clausen+Functions">Clausen functins</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Coulomb+Functions">Coulomb functins</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Coupling+Coefficients">Coupling
coefficients</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Dawson+Function">Dawson coefficients</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Debye+Functions">Debye coefficients</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Dilogarithm">Dilogarithm</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Elementary+Operations">Elementary
operations</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Elliptic+Integrals">Elliptic integrals</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Elliptic+Functions+%28Jacobi%29">Elliptic
functions</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Error+Functions">Error functions</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Exponential+Functions">Exponential
functions</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Exponential+Integrals">Exponential
integrals</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Fermi-Dirac+Functions">Fermi-Dirac function</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Gamma+Function">Gamma function</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Gegenbauer+Functions">Gegenbauer functions</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Hypergeometric+Functions">Hypergeometric
functions</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Laguerre+Functions">Laguerre functions</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Lambert+W+Functions">Lambert W functions</a></p>
</li><li>
<p><a
href="sf_rdoc.html#label-Legendre+Functions+and+Spherical+Harmonics">Legendre
functions and spherical harmonics</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Logarithm+and+Related+Functions">Logarithm and
related functions</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Mathieu+functions">Mathieu functions</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Power+Functions">Power function</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Psi+%28Digamma%29+Function">Psi (digamma)
function</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Synchrotron+Functions">Synchrotron
functions</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Transport+Functions">Transport functions</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Trigonometric+Functions">Trigonometric
functions</a></p>
</li><li>
<p><a href="sf_rdoc.html#label-Zeta+Functions">Zeta functions</a></p>
</li></ol>

<h2 id="label-Usage">Usage<span><a href="#label-Usage">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>Ruby/GSL provides all the (documented) GSL special functions as module
functions under the <code>GSL::Sf</code> module. The prefix
<code>gsl_sf_</code> in C functions is replaced by the module identifier
<code>GSL::Sf::</code>. For example, the regular Bessel function of 0-th
order is evaluated as</p>

<pre>y = GSL::Sf::bessel_J0(x)</pre>

<p>or</p>

<pre>include GSL::Sf
y = bessel_J0(x)</pre>

<p>where the argument <code>x</code> can be a <code>Numeric</code>,
<code>GSL::Vector</code>, <code>GSL::Matrix</code>, or an
<code>NArray</code> object.</p>

<p>Example:</p>

<pre class="ruby"><span class="ruby-operator">&gt;&gt;</span> <span class="ruby-identifier">require</span>(<span class="ruby-string">&quot;gsl&quot;</span>)
=<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>
<span class="ruby-operator">&gt;&gt;</span> <span class="ruby-identifier">x</span> = <span class="ruby-value">1.0</span>
=<span class="ruby-operator">&gt;</span> <span class="ruby-value">1.0</span>
<span class="ruby-operator">&gt;&gt;</span> <span class="ruby-constant">Sf</span><span class="ruby-operator">::</span><span class="ruby-identifier">bessel_J0</span>(<span class="ruby-identifier">x</span>)
=<span class="ruby-operator">&gt;</span> <span class="ruby-value">0.765197686557967</span>
<span class="ruby-operator">&gt;&gt;</span> <span class="ruby-identifier">x</span> = <span class="ruby-constant">Vector</span>[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>]
=<span class="ruby-operator">&gt;</span> <span class="ruby-constant">GSL</span><span class="ruby-operator">::</span><span class="ruby-constant">Vector</span>
[ <span class="ruby-value">1.000e+00</span> <span class="ruby-value">2.000e+00</span> <span class="ruby-value">3.000e+00</span> <span class="ruby-value">4.000e+00</span> ]
<span class="ruby-operator">&gt;&gt;</span> <span class="ruby-constant">Sf</span><span class="ruby-operator">::</span><span class="ruby-identifier">bessel_J0</span>(<span class="ruby-identifier">x</span>)
=<span class="ruby-operator">&gt;</span> <span class="ruby-constant">GSL</span><span class="ruby-operator">::</span><span class="ruby-constant">Vector</span>
[ <span class="ruby-value">7.652e-01</span> <span class="ruby-value">2.239e-01</span> <span class="ruby-operator">-</span><span class="ruby-value">2.601e-01</span> <span class="ruby-operator">-</span><span class="ruby-value">3.971e-01</span> ]
<span class="ruby-operator">&gt;&gt;</span> <span class="ruby-identifier">x</span> = <span class="ruby-constant">Matrix</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">4</span>, <span class="ruby-value">2</span>, <span class="ruby-value">2</span>]
=<span class="ruby-operator">&gt;</span> <span class="ruby-constant">GSL</span><span class="ruby-operator">::</span><span class="ruby-constant">Matrix</span>
[  <span class="ruby-value">1.000e+00</span>  <span class="ruby-value">2.000e+00</span>
   <span class="ruby-value">3.000e+00</span>  <span class="ruby-value">4.000e+00</span> ]
<span class="ruby-operator">&gt;&gt;</span> <span class="ruby-constant">Sf</span><span class="ruby-operator">::</span><span class="ruby-identifier">bessel_J0</span>(<span class="ruby-identifier">x</span>)
=<span class="ruby-operator">&gt;</span> <span class="ruby-constant">GSL</span><span class="ruby-operator">::</span><span class="ruby-constant">Matrix</span>
[  <span class="ruby-value">7.652e-01</span>  <span class="ruby-value">2.239e-01</span>
  <span class="ruby-value">-2.601e-01</span> <span class="ruby-operator">-</span><span class="ruby-value">3.971e-01</span> ]
<span class="ruby-operator">&gt;&gt;</span> <span class="ruby-identifier">x</span> = <span class="ruby-constant">NArray</span>[<span class="ruby-value">1.0</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>]
=<span class="ruby-operator">&gt;</span> <span class="ruby-constant">NArray</span>.<span class="ruby-identifier">float</span>(<span class="ruby-value">4</span>)<span class="ruby-operator">:</span>
[ <span class="ruby-value">1.0</span>, <span class="ruby-value">2.0</span>, <span class="ruby-value">3.0</span>, <span class="ruby-value">4.0</span> ]
<span class="ruby-operator">&gt;&gt;</span> <span class="ruby-constant">Sf</span><span class="ruby-operator">::</span><span class="ruby-identifier">bessel_J0</span>(<span class="ruby-identifier">x</span>)
=<span class="ruby-operator">&gt;</span> <span class="ruby-constant">NArray</span>.<span class="ruby-identifier">float</span>(<span class="ruby-value">4</span>)<span class="ruby-operator">:</span>
[ <span class="ruby-value">0.765198</span>, <span class="ruby-value">0.223891</span>, <span class="ruby-value">-0.260052</span>, <span class="ruby-value">-0.39715</span> ]
</pre>

<h2 id="label-Result+class"><code>Result</code> class<span><a href="#label-Result+class">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>The Ruby methods as wrappers of GSL functions with the suffix
“<code>_e</code>” return <code>GSL::Sf::Result</code> objects which contain
the function values as well as error information.</p>

<h3 id="label-Result+instance+methods"><code>Result</code> instance methods<span><a href="#label-Result+instance+methods">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::Result#val Returns the value.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::Result#err Returns the error.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::Result_e10#val Returns the value.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::Result_e10#err Returns the error.</p>
</li></ul>

<h2 id="label-Modes">Modes<span><a href="#label-Modes">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>The goal of the library is to achieve double precision accuracy wherever
possible. However the cost of evaluating some special functions to double
precision can be significant, particularly where very high order terms are
required. In these cases a <code>mode</code> argument allows the accuracy
of the function to be reduced in order to improve performance. The
following precision levels are available for the mode argument, given by
Fixnum constants under the <code>GSL</code> module,</p>
<ul><li>
<p><code>GSL::PREC_DOUBLE</code> Double-precision, a relative accuracy of
approximately 2 * 10^-16.</p>
</li><li>
<p><code>GSL::PREC_SINGLE</code> Single-precision, a relative accuracy of
approximately 10^-7.</p>
</li><li>
<p><code>GSL::PREC_APPROX</code> Approximate values, a relative accuracy of
approximately 5 * 10^-4.</p>
</li></ul>

<p>The approximate mode provides the fastest evaluation at the lowest
accuracy.</p>

<h2 id="label-Airy+Functions+and+Derivatives">Airy Functions and Derivatives<span><a href="#label-Airy+Functions+and+Derivatives">&para;</a> <a href="#documentation">&uarr;</a></span></h2>
<hr>
<ul><li>
<p>GSL::Sf::airy_Ai(x, mode = GSL::PREC_DOUBLE)</p>

<p>Computes the Airy function Ai(x) with an accuracy specified by
<code>mode</code>.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::airy_Bi(x, mode = GSL::PREC_DOUBLE)</p>

<p>Computes the Airy function Bi(x) with an accuracy specified by
<code>mode</code>.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::airy_Ai_scaled(x, mode = GSL::PREC_DOUBLE)</p>

<p>Computes a scaled version of the Airy function S_A(x) Ai(x). For x&gt;0 the
scaling factor S_A(x) is exp(+(2/3) x^(3/2)), and is 1 for x&lt;0.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::airy_Bi_scaled(x, mode = GSL::PREC_DOUBLE)</p>

<p>Computes a scaled version of the Airy function S_B(x) Bi(x). For x&gt;0 the
scaling factor S_B(x) is exp(-(2/3) x^(3/2)), and is 1 for x&lt;0.</p>
</li></ul>

<h3 id="label-Derivatives+of+Airy+Functions">Derivatives of Airy Functions<span><a href="#label-Derivatives+of+Airy+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::airy_Ai_deriv(x, mode = GSL::PREC_DOUBLE)</p>

<p>Computes the Airy function derivative Ai&#39;(x) with an accuracy specified
by <code>mode</code>.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::airy_Bi_deriv(x, mode = GSL::PREC_DOUBLE)</p>

<p>Computes the Airy function derivative Bi&#39;(x) with an accuracy specified
by <code>mode</code>.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::airy_Ai_deriv_scaled(x, mode = GSL::PREC_DOUBLE)</p>

<p>Computes the derivative of the scaled Airy function S_A(x) Ai(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::airy_Bi_deriv_scaled(x, mode = GSL::PREC_DOUBLE)</p>

<p>Computes the derivative of the scaled Airy function S_B(x) Bi(x).</p>
</li></ul>

<h3 id="label-Zeros+of+Airy+Functions">Zeros of Airy Functions<span><a href="#label-Zeros+of+Airy+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::airy_zero_Ai(s)</p>

<p>Computes the location of the <code>s</code>-th zero of the Airy function
Ai(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::airy_zero_Bi(s)</p>

<p>Computes the location of the <code>s</code>-th zero of the Airy function
Bi(x).</p>
</li></ul>

<h3 id="label-Zeros+of+Derivatives+of+Airy+Functions">Zeros of Derivatives of Airy Functions<span><a href="#label-Zeros+of+Derivatives+of+Airy+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::airy_zero_Ai_deriv(s)</p>

<p>Computes the location of the <code>s</code>-th zero of the Airy function
derivative Ai&#39;(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::airy_zero_Bi_deriv(s)</p>

<p>Computes the location of the <code>s</code>-th zero of the Airy function
derivative Bi&#39;(x).</p>
</li></ul>

<h2 id="label-Bessel+Functions">Bessel Functions<span><a href="#label-Bessel+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<h3 id="label-Regular+Cylindrical+Bessel+Functions">Regular Cylindrical Bessel Functions<span><a href="#label-Regular+Cylindrical+Bessel+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::bessel_J0(x)</p>

<p>Computes the regular cylindrical Bessel function of zeroth order, J_0(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_J1(x)</p>

<p>Computes the regular cylindrical Bessel function of first order, J_1(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_Jn(n, x)</p>

<p>Computes the regular cylindrical Bessel function of order <code>n</code>,
J_n(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_Jn_array(nmin, nmax, x)</p>

<p>Computes the values of the regular cylindrical Bessel functions J_n(x) for
n from <code>nmin</code> to <code>nmax</code> inclusive, and returns the
results as a <code>GSL::Vector</code> object. The values are computed using
recurrence relations, for efficiency, and therefore may differ slightly
from the exact values.</p>
</li></ul>

<h3 id="label-Irregular+Cylindrical+Bessel+Functions">Irregular Cylindrical Bessel Functions<span><a href="#label-Irregular+Cylindrical+Bessel+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::bessel_Y0(x)</p>

<p>Computes the irregular cylindrical Bessel function of zeroth order, Y_0(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_Y1(x)</p>

<p>Computes the irregular cylindrical Bessel function of first order, Y_1(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_Yn(n, x)</p>

<p>Computes the irregular cylindrical Bessel function of order <code>n</code>,
Y_n(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_Yn_array(nmin, nmax, x)</p>

<p>Computes the values of the irregular cylindrical Bessel functions Y_n(x)
for n from <code>nmin</code> to <code>nmax</code> inclusive, and returns
the results as a <code>GSL::Vector</code> object. The values are computed
using recurrence relations, for efficiency, and therefore may differ
slightly from the exact values.</p>
</li></ul>

<h3 id="label-Regular+Modified+Cylindrical+Bessel+Functions">Regular Modified Cylindrical Bessel Functions<span><a href="#label-Regular+Modified+Cylindrical+Bessel+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::bessel_I0(x)</p>

<p>Computes the regular modified cylindrical Bessel function of zeroth order,
I_0(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_I1(x)</p>

<p>Computes the regular modified cylindrical Bessel function of first order,
I_1(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_In(n, x)</p>

<p>Computes the regular modified cylindrical Bessel function of order
<code>n</code>, I_n(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_In_array(nmin, nmax, x)</p>

<p>Computes the values of the regular modified cylindrical Bessel functions
I_n(x) for n from <code>nmin</code> to <code>nmax</code> inclusive, and
returns the results as a <code>GSL::Vector</code> object. The start of the
range <code>nmin</code> must be positive or zero. The values are computed
using recurrence relations, for efficiency, and therefore may differ
slightly from the exact values.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_I0_scaled(x)</p>

<p>Computes the scaled regular modified cylindrical Bessel function of zeroth
order, exp(-|x|) I_0(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_I1_scaled(x)</p>

<p>Computes the scaled regular modified cylindrical Bessel function of first
order, exp(-|x|)I_1(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_In_scaled(n, x)</p>

<p>Computes the scaled regular modified cylindrical Bessel function of order
<code>n</code>,  exp(-|x|) I_n(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_In_scaled_array(nmin, nmax, x)</p>

<p>Computes the values of the scaled regular modified cylindrical Bessel
functions exp(-|x|) I_n(x) for n from <code>nmin</code> to
<code>nmax</code> inclusive, and returns the results as a
<code>GSL::Vector</code> object. The start of the range <code>nmin</code> 
must be positive or zero. The values are computed using recurrence
relations,  for efficiency, and therefore may differ slightly from the
exact values.</p>
</li></ul>

<h3 id="label-Irregular+Modified+Cylindrical+Bessel+Functions">Irregular Modified Cylindrical Bessel Functions<span><a href="#label-Irregular+Modified+Cylindrical+Bessel+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::bessel_K0(x)</p>

<p>Computes the irregular modified cylindrical Bessel function of zeroth
order, K_0(x), for x &gt; 0.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_K1(x)</p>

<p>Computes the irregular modified cylindrical Bessel function of first order,
K_1(x), for x &gt; 0.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_Kn(n, x)</p>

<p>Computes the irregular modified cylindrical Bessel function of order
<code>n</code>, K_n(x), for x &gt; 0.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_Kn_array(nmin, nmax, x)</p>

<p>Computes the values of the irregular modified cylindrical Bessel functions
K_n(x) for n from <code>nmin</code> to <code>nmax</code> inclusive, and
returns the results as a <code>GSL::Vector</code> object. The start of the
range <code>nmin</code> must be positive or zero. The domain of the
function is <code>x&gt;0</code>. The values are computed using recurrence
relations, for efficiency, and therefore may differ slightly from the exact
values.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_K0_scaled(x)</p>

<p>Computes the scaled irregular modified cylindrical Bessel function of
zeroth order exp(x) K_0(x) for x&gt;0.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_K1_scaled(x)</p>

<p>Computes the scaled irregular modified cylindrical Bessel function of first
order exp(x) K_1(x) for x&gt;0</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_Kn_scaled(n, x)</p>

<p>Computes the scaled irregular modified cylindrical Bessel function of order
<code>n</code>, exp(x) K_n(x), for x&gt;0.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_Kn_scaled_array(nmin, nmax, x)</p>

<p>Computes the values of the scaled irregular cylindrical Bessel functions
exp(x) K_n(x) for n from <code>nmin</code> to <code>nmax</code> inclusive,
and returns the results as a <code>GSL::Vector</code> object. The start of
the range nmin must be positive or zero. The domain of the function is
x&gt;0. The values are computed using recurrence relations, for efficiency,
and therefore may differ slightly from the exact values.</p>
</li></ul>

<h3 id="label-Regular+Spherical+Bessel+Functions">Regular Spherical Bessel Functions<span><a href="#label-Regular+Spherical+Bessel+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::bessel_j0(x)</p>

<p>Computes the regular spherical Bessel function of zeroth order, j0(x) =
sin(x)/x.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_j1(x)</p>

<p>Computes the regular spherical Bessel function of first order, j1(x) =
(sin(x)/x - cos(x))/x.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_j2(x)</p>

<p>Computes the regular spherical Bessel function of second order, j2(x) =
((3/x^2 - 1)sin(x) - 3cos(x)/x)/x.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_jl(l, x)</p>

<p>Computes the regular spherical Bessel function of order l, j_l(x), for l
&gt;= 0 and x &gt;= 0.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_jl_array(lmax, x)</p>

<p>Computes the values of the regular spherical Bessel functions j_l(x) for l
from 0 to <code>lmax</code> inclusive for lmax &gt;= 0 and x &gt;= 0, and
returns the results as a <code>GSL::Vector</code> object. The values are
computed using recurrence relations, for efficiency, and therefore may
differ slightly from the exact values.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_jl_steed_array(lmax, x)</p>

<p>This method uses Steed&#39;s method to compute the values of the regular
spherical Bessel functions j_l(x) for l from 0 to <code>lmax</code>
inclusive for <code>lmax</code> &gt;= 0 and x &gt;= 0, and returns the
results as a <code>GSL::Vector</code> object.  The Steed/Barnett algorithm
is described in Comp. Phys. Comm. 21, 297 (1981). Steed&#39;s method is
more stable than the recurrence used in the other functions but is also
slower.</p>
</li></ul>

<h3 id="label-Irregular+Spherical+Bessel+Functions">Irregular Spherical Bessel Functions<span><a href="#label-Irregular+Spherical+Bessel+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::bessel_y0(x)</p>

<p>Computes the irregular spherical Bessel function of zeroth order, y_0(x) =
-cos(x)/x.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_y1(x)</p>

<p>Computes the irregular spherical Bessel function of first order, y_1(x) =
-(cos(x)/x + sin(x))/x.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_y2(x)</p>

<p>Computes the irregular spherical Bessel function of second order, y_2(x) =
(-3/x^3 + 1/x)cos(x) - (3/x^2)sin(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_yl(l, x)</p>

<p>Computes the irregular spherical Bessel function of order <code>l</code>,
y_l(x), for l &gt;= 0.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_yl_array(lmax, x)</p>

<p>This method computes the values of the irregular spherical Bessel functions
y_l(x) for l from 0 to <code>lmax</code> inclusive for <code>lmax &gt;=
0</code>), and returns the results as a <code>GSL::Vector</code> object.
The values are computed using recurrence relations, for efficiency, and
therefore may differ slightly from the exact values.</p>
</li></ul>

<h3 id="label-Regular+Modified+Spherical+Bessel+Functions">Regular Modified Spherical Bessel Functions<span><a href="#label-Regular+Modified+Spherical+Bessel+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::bessel_i0_scaled(x)</p>

<p>Computes the scaled regular modified spherical Bessel function of zeroth
order, exp(-|x|) i_0(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_i1_scaled(x)</p>

<p>Computes the scaled regular modified spherical Bessel function of first
order, exp(-|x|) i_1(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_i2_scaled(x)</p>

<p>Computes the scaled regular modified spherical Bessel function of second
order, exp(-|x|) i_2(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_il_scaled(l, x)</p>

<p>Computes the scaled regular modified spherical Bessel function of order
<code>l</code>, exp(-|x|) i_l(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_il_scaled_array(lmax, x)</p>

<p>This routine computes the values of the scaled regular modified cylindrical
Bessel functions exp(-|x|) i_l(x) for l from 0 to <code>lmax</code>
inclusive for <code>lmax &gt;= 0</code>,     and returns the results as a
<code>GSL::Vector</code> object. The values are computed using recurrence
relations, for efficiency, and therefore may differ slightly from the exact
values.</p>
</li></ul>

<h3 id="label-Irregular+Modified+Spherical+Bessel+Functions">Irregular Modified Spherical Bessel Functions<span><a href="#label-Irregular+Modified+Spherical+Bessel+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::bessel_k0_scaled(x)</p>

<p>Computes the scaled irregular modified spherical Bessel function of zeroth
order, exp(-|x|) k_0(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_k1_scaled(x)</p>

<p>Computes the scaled irregular modified spherical Bessel function of first
order, exp(-|x|) k_1(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_k2_scaled(x)</p>

<p>Computes the scaled irregular modified spherical Bessel function of second
order, exp(-|x|) k_2(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_kl_scaled(l, x)</p>

<p>Computes the scaled irregular modified spherical Bessel function of order
<code>l</code>, exp(-|x|) k_l(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_kl_scaled_array(lmax, x)</p>

<p>This routine computes the values of the scaled irregular modified
cylindrical Bessel functions exp(-|x|) k_l(x) for l from 0 to
<code>lmax</code> inclusive for <code>lmax &gt;= 0</code>,     and returns
the results as a <code>GSL::Vector</code> object. The values are computed
using recurrence relations, for efficiency, and therefore may differ
slightly from the exact values.</p>
</li></ul>

<h3 id="label-Regular+Bessel+Function+-+Fractional+Order">Regular Bessel Function - Fractional Order<span><a href="#label-Regular+Bessel+Function+-+Fractional+Order">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::bessel_Jnu(nu, x)</p>

<p>Computes the regular cylindrical Bessel function of fractional order
<code>nu</code>, J_nu(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_sequence_Jnu_e(nu, v)</p>
</li><li>
<p>GSL::Sf::bessel_sequence_Jnu_e(nu, mode, v)</p>

<p>These compute the regular cylindrical Bessel function of fractional order
nu, J_nu(x), evaluated at a series of x values. The
<code>GSL::Vector</code> object <code>v</code> contains the x values. They
are assumed to be strictly ordered and positive. The vector is over-written
with the values of J_nu(x_i).</p>
</li></ul>

<h3 id="label-Irregular+Bessel+Functions+-+Fractional+Order">Irregular Bessel Functions - Fractional Order<span><a href="#label-Irregular+Bessel+Functions+-+Fractional+Order">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::bessel_Ynu(nu, x)</p>

<p>Computes the irregular cylindrical Bessel function of fractional order
<code>nu</code>, Y_nu(x).</p>
</li></ul>

<h3 id="label-Regular+Modified+Bessel+Functions+-+Fractional+Order">Regular Modified Bessel Functions - Fractional Order<span><a href="#label-Regular+Modified+Bessel+Functions+-+Fractional+Order">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::bessel_Inu(nu, x)</p>

<p>Computes the regular modified Bessel function of fractional order
<code>nu</code>, I_nu(x) for x&gt;0, nu&gt;0.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_Inu_scaled(nu, x)</p>

<p>Computes the scaled regular modified Bessel function of fractional order
<code>nu</code>, exp(-|x|) I_nu(x) for x&gt;0, nu&gt;0.</p>
</li></ul>

<h3 id="label-Irregular+Modified+Bessel+Functions+-+Fractional+Order">Irregular Modified Bessel Functions - Fractional Order<span><a href="#label-Irregular+Modified+Bessel+Functions+-+Fractional+Order">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::bessel_Knu(nu, x)</p>

<p>Computes the irregular modified Bessel function of fractional order
<code>nu</code>, K_nu(x) for x&gt;0, nu&gt;0.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_lnKnu(nu, x)</p>

<p>Computes the logarithm of the irregular modified Bessel function of
fractional order <code>nu</code>, ln(K_nu(x)) for x&gt;0, nu&gt;0</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_Knu_scaled(nu, x)</p>

<p>Computes the scaled irregular modified Bessel function of fractional order
<code>nu</code>, exp(+|x|) K_nu(x) for x&gt;0, nu&gt;0.</p>
</li></ul>

<h3 id="label-Zeros+of+Regular+Bessel+Functions">Zeros of Regular Bessel Functions<span><a href="#label-Zeros+of+Regular+Bessel+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::bessel_zero_J0(s)</p>

<p>Computes the location of the <code>s</code>-th positive zero of the Bessel
function J_0(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_zero_J1(s)</p>

<p>Computes the location of the <code>s</code>-th positive zero of the Bessel
function J_1(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::bessel_zero_Jnu(nu, s)</p>

<p>Computes the location of the <code>s</code>-th positive zero of the Bessel
function J_nu(x). The current implementation does not support negative
values of <code>nu</code>.</p>
</li></ul>

<h2 id="label-Clausen+Functions">Clausen Functions<span><a href="#label-Clausen+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h2>
<hr>
<ul><li>
<p>GSL::Sf::clausen(x)</p>

<p>The Clausen function is defined by the following integral,</p>

<pre>Cl_2(x) = - int_0^x dt log(2 sin(t/2))</pre>

<p>It is related to the dilogarithm by Cl_2(theta) = Im Li_2(exp(i theta)).</p>
</li></ul>

<h2 id="label-Coulomb+Functions">Coulomb Functions<span><a href="#label-Coulomb+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h2>
<hr>
<ul><li>
<p>GSL::Sf::hydrogenicR_1(Z, r)</p>

<p>Computes the lowest-order normalized hydrogenic bound state radial
wavefunction R_1 := 2Z sqrt{Z} exp(-Z r).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::hydrogenicR(n, l, Z, r)</p>

<p>Computes the <code>n</code>-th normalized hydrogenic bound state radial
wavefunction,</p>

<pre>R_n := 2 (Z^{3/2}/n^2) sqrt{(n-l-1)!/(n+l)!}exp(-Z r/n) (2Z/n)^l L^{2l+1}_{n-l-1}(2Z/n r).</pre>

<p>The normalization is chosen such that the wavefunction psi is given by
psi(n,l,r) = R_n Y_{lm}.</p>
</li></ul>

<h3 id="label-Coulomb+Wave+Functions">Coulomb Wave Functions<span><a href="#label-Coulomb+Wave+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::coulomb_wave_FG_e(eta, x, L, k)</p>

<p>This method computes the coulomb wave functions F_L(eta,x), G_{L-k}(eta,x)
and their derivatives with respect to x, F&#39;_L(eta,x)
G&#39;_{L-k}(eta,x). The parameters are restricted to <code>L</code>,
<code>L-k &gt; -1/2</code>, <code>x &gt; 0</code> and integer
<code>k</code>. Note that <code>L</code> itself is not restricted to being
an integer. The results are returned as an array of 7 elements, <code>[F,
G, Fp, Gp, exp_F, exp_G, status]</code>, as <code>F, G</code> for the
function values, <code>Fp, Gp</code> for the derivative values, and
<code>exp_F, exp_G</code> for scaling exponents in the case of overflow
occurs.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::coulomb_wave_F_array(Lmin, kmax, eta, x)</p>

<p>This method computes the function F_L(eta,x) for L = <code>Lmin ... Lmin +
kmax</code> and returns the results as an array of 3 elements,
<code>[fc_array, F_exponent, status]</code>. In the case of overflow, the
exponent is returned in <code>F_exponent</code>.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::coulomb_wave_FG_array(Lmin, kmax, eta, x)</p>

<p>This method computes the functions F_L(eta,x), G_L(eta,x) for L =
<code>Lmin</code> … <code>Lmin + kmax</code> and returns the results as an
array of 5 elements, <code>[fc_array, gc_array, F_exponent, G_exponent,
status]</code>. In the case of overflow the exponents are stored in
<code>F_exponent</code> and <code>G_exponent</code>.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::coulomb_wave_FGp_array(Lmin, kmax, eta, x)</p>

<p>This method computes the functions F_L(eta,x), G_L(eta,x) and their
derivatives F&#39;_L(eta,x), G&#39;_L(eta,x) for L = <code>Lmin</code> …
<code>Lmin + kmax</code> and returns the results as an array of 7 elements,
<code>[fc_array, gc_array, fcp_array, gcp_array, F_exponent, G_exponent,
status]</code>. In the case of overflow the exponents are stored in
<code>F_exponent</code> and <code>G_exponent</code>.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::coulomb_wave_sphF_array(Lmin, kmax, eta, x)</p>

<p>This method computes the Coulomb wave function divided by the argument
F_L(eta, x)/x for L = <code>Lmin</code> … <code>Lmin + kmax</code>, and
returns the results as an array of 3 elememnts, <code>[fc_array,
F_exponent, status]</code>. In the case of overflow the exponent is stored
in <code>F_exponent</code>. This function reduces to spherical Bessel
functions in the limit <code>eta</code> to 0.</p>
</li></ul>

<h3 id="label-Coulomb+Wave+Function+Normalization+Constant">Coulomb Wave Function Normalization Constant<span><a href="#label-Coulomb+Wave+Function+Normalization+Constant">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::coulomb_CL_e(L, eta)</p>

<p>This method computes the Coulomb wave function normalization constant
C_L(eta) for L &gt; -1.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::gsl_sf_coulomb_CL_array(Lmin, kmax, eta)</p>

<p>This method computes the coulomb wave function normalization constant
C_L(eta) for L = Lmin … Lmin + kmax, Lmin &gt; -1.</p>
</li></ul>

<h2 id="label-Coupling+Coefficients">Coupling Coefficients<span><a href="#label-Coupling+Coefficients">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>The Wigner 3-j, 6-j and 9-j symbols give the coupling coefficients for
combined angular momentum vectors. Since the arguments of the standard
coupling coefficient functions are integer or half-integer, the arguments
of the following functions are, by convention, integers equal to twice the
actual spin value. For information on the 3-j coefficients see Abramowitz
&amp; Stegun, Section 27.9.</p>
<hr>
<ul><li>
<p>GSL::Sf::coupling_3j(two_ja, two_jb, two_jc, two_ma, two_mb, two_mc)</p>

<p>Computes the Wigner 3-j coefficient,</p>

<pre>ja jb jc
ma mb mc</pre>

<p>where the arguments are given in half-integer units, <code>ja = two_ja/2,
ma = two_ma/2</code>, etc.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::coupling_6j(two_ja, two_jb, two_jc, two_jd, two_je, two_jf)</p>

<p>Computes the Wigner 6-j coefficient,</p>

<pre>ja jb jc
jd je jf</pre>

<p>where the arguments are given in half-integer units, <code>ja = two_ja/2,
ma = two_ma/2</code>, etc.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::coupling_9j(two_ja, two_jb, two_jc, two_jd, two_je, two_jf,
two_jg, two_jh, two_ji)</p>

<p>Computes the Wigner 9-j coefficient,</p>

<pre>ja jb jc
jd je jf
jg jh ji</pre>

<p>where the arguments are given in half-integer units, <code>ja = two_ja/2,
ma = two_ma/2</code>, etc.</p>
</li></ul>

<h2 id="label-Dawson+Function">Dawson Function<span><a href="#label-Dawson+Function">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>The Dawson integral is defined by exp(-x^2) int_0^x dt exp(t^2). A table of
Dawson&#39;s integral can be found in Abramowitz &amp; Stegun, Table 7.5.</p>
<hr>
<ul><li>
<p>GSL::Sf::dawson(x)</p>

<p>This method computes the value of Dawson&#39;s integral for <code>x</code>.</p>
</li></ul>

<h2 id="label-Debye+Functions">Debye Functions<span><a href="#label-Debye+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>The Debye functions are defined by the integral D_n(x) = n/x^n int_0^x dt
(t^n/(e^t - 1)). For further information see Abramowitz &amp; Stegun,
Section 27.1.</p>
<hr>
<ul><li>
<p>GSL::Sf::debye_1(x)</p>
</li><li>
<p>GSL::Sf::debye_2(x)</p>
</li><li>
<p>GSL::Sf::debye_3(x)</p>
</li><li>
<p>GSL::Sf::debye_4(x)</p>

<p>These methods Compute the n-th order Debye functions.</p>
</li></ul>

<h2 id="label-Dilogarithm">Dilogarithm<span><a href="#label-Dilogarithm">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<h3 id="label-Real+Argument">Real Argument<span><a href="#label-Real+Argument">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::dilog(x)</p>

<p>Computes the dilogarithm for a real argument. In Lewin&#39;s notation this
is Li_2(x), the real part of the dilogarithm of a real <code>x</code>. It
is defined by the integral representation Li_2(x) = - Re int_0^x ds
log(1-s) / s. Note that Im(Li_2(x)) = 0 for x &lt;= 1, and -pi log(x) for x
&gt; 1.</p>
</li></ul>

<h3 id="label-Complex+Argument">Complex Argument<span><a href="#label-Complex+Argument">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::complex_dilog_e(r, theta)</p>

<p>This method computes the full complex-valued dilogarithm for the complex
argument z = r exp(i theta). The result is returned as an array of 2
elements, <code>[re, im]</code>, each of them is a
<code>GSL::Sf::Result</code> object.</p>
</li></ul>

<h2 id="label-Elementary+Operations">Elementary Operations<span><a href="#label-Elementary+Operations">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>The following methods allow for the propagation of errors when combining
quantities by multiplication.</p>
<hr>
<ul><li>
<p>GSL::Sf::multiply_e(x, y)</p>

<p>This method multiplies <code>x</code> and <code>y</code> and returns the
product as a <code>GSL::Sf::Result</code> object.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::multiply_err_e(x, dx, y, dy)</p>

<p>This method multiplies <code>x</code> and <code>y</code> with associated
absolute errors <code>dx</code> and <code>dy</code>,  and returns the
product as a <code>GSL::Sf::Result</code> object.</p>
</li></ul>

<h2 id="label-Elliptic+Integrals">Elliptic Integrals<span><a href="#label-Elliptic+Integrals">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<h3 id="label-Legendre+Form+of+Complete+Elliptic+Integrals">Legendre Form of Complete Elliptic Integrals<span><a href="#label-Legendre+Form+of+Complete+Elliptic+Integrals">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::ellint_Kcomp(k, mode = GSL::PREC_DOUBLE)</p>

<p>Computes the complete elliptic integral K(k) to the accuracy specified by
the mode variable <code>mode</code>.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::ellint_Ecomp(k, mode = GSL::PREC_DOUBLE)</p>

<p>Computes the complete elliptic integral E(k) to the accuracy specified by
the mode variable <code>mode</code>.</p>
</li></ul>

<h3 id="label-Legendre+Form+of+Incomplete+Elliptic+Integrals">Legendre Form of Incomplete Elliptic Integrals<span><a href="#label-Legendre+Form+of+Incomplete+Elliptic+Integrals">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::ellint_F(phi, k, mode = GSL::PREC_DOUBLE)</p>

<p>Computes the incomplete elliptic integral E(phi, k) to the accuracy
specified by the mode variable <code>mode</code>.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::ellint_P(phi, k, n, mode = GSL::PREC_DOUBLE)</p>

<p>Computes the incomplete elliptic integral P(phi, k, n) to the accuracy
specified by the mode variable <code>mode</code>.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::ellint_D(phi, k, n, mode = GSL::PREC_DOUBLE)</p>

<p>Computes the incomplete elliptic integral D(phi, k, n) which is defined
through the Carlson form RD(x, y, z) by the following relation,</p>

<pre>D(phi, k, n) = RD (1-sin^2(phi), 1-k^2 sin^2(phi), 1).</pre>
</li></ul>

<h3 id="label-Carlson+Forms">Carlson Forms<span><a href="#label-Carlson+Forms">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::ellint_RC(x, y, mode = GSL::PREC_DOUBLE)</p>

<p>Computes the incomplete elliptic integral RC(x, y) to the accuracy
specified by the mode variable <code>mode</code>.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::ellint_RD(x, y, z, mode = GSL::PREC_DOUBLE)</p>

<p>Computes the incomplete elliptic integral RD(x, y, z) to the accuracy
specified by the mode variable <code>mode</code>.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::ellint_RF(x, y, z, mode = GSL::PREC_DOUBLE)</p>

<p>Computes the incomplete elliptic integral RF(x, y, z) to the accuracy
specified by the mode variable <code>mode</code>.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::ellint_RJ(x, y, z, p, mode = GSL::PREC_DOUBLE)</p>

<p>Computes the incomplete elliptic integral RJ(x, y, z, p) to the accuracy
specified by the mode variable <code>mode</code>.</p>
</li></ul>

<h2 id="label-Elliptic+Functions+%28Jacobi%29">Elliptic Functions (Jacobi)<span><a href="#label-Elliptic+Functions+%28Jacobi%29">&para;</a> <a href="#documentation">&uarr;</a></span></h2>
<hr>
<ul><li>
<p>GSL::Sf::gsl_sf_elljac(u, m)</p>
</li><li>
<p>GSL::Sf::gsl_sf_elljac_e(u, m)</p>

<p>These methods compute the Jacobian elliptic functions sn(u|m), cn(u|m),
dn(u|m) by descending Landen transformations, and returns the result as an
array of 3 elements.</p>
</li></ul>

<h2 id="label-Error+Functions">Error Functions<span><a href="#label-Error+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h2>
<hr>
<ul><li>
<p>GSL::Sf::erf(x)</p>

<p>Computes the error function erf(x) = (2/sqrt(pi)) int_0^x dt exp(-t^2).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::erfc(x)</p>

<p>Computes the complementary error function.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::log_erfc(x)</p>

<p>Computes the logarithm of the complementary error function log(erfc(x)).</p>
</li></ul>

<h3 id="label-Probability+functions">Probability functions<span><a href="#label-Probability+functions">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::erf_Z(x)</p>

<p>Computes the Gaussian probability density function Z(x) = (1/sqrt{2 pi})
exp(-x^2/2).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::erf_Q(x)</p>

<p>Computes the upper tail of the Gaussian probability function Q(x) =
(1/sqrt{2 pi}) int_x^infty dt exp(-t^2/2).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::hazard(x)</p>

<p>The hazard function for the normal distribution, also known as the inverse
Mill&#39;s ratio, is defined as h(x) = Z(x)/Q(x) = sqrt{2/pi exp(-x^2 / 2)
/ erfc(x/sqrt 2)}. It decreases rapidly as x approaches -infty and
asymptotes to h(x) sim x as x approaches +infty.</p>
</li></ul>

<h2 id="label-Exponential+Functions">Exponential Functions<span><a href="#label-Exponential+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h2>
<hr>
<ul><li>
<p>GSL::Sf::exp(x)</p>
</li><li>
<p>GSL::Sf::exp_e(x)</p>

<p>These methods provide an exponential function exp(x) using GSL semantics
and error checking.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::exp_e10_e(x)</p>

<p>This method computes the exponential exp(x) using the
<code>GSL::Sf::Result_e10</code> type to return a result with extended
range. This may be useful if the value of exp(x) would overflow the numeric
range of <code>double</code>.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::exp_mult(x, y)</p>
</li><li>
<p>GSL::Sf::exp_mult_e(x, y)</p>
</li><li>
<p>GSL::Sf::exp_mult_e10_e(x, y)</p>

<p>Exponentiate <code>x</code> and multiply by the factor <code>y</code> to
return the product y exp(x).</p>
</li></ul>

<h3 id="label-Relative+Exponential+Functions">Relative Exponential Functions<span><a href="#label-Relative+Exponential+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::expm1(x)</p>

<p>Computes the quantity exp(x)-1 using an algorithm that is accurate for
small <code>x</code>.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::exprel(x)</p>

<p>Computes the quantity (exp(x)-1)/x using an algorithm that is accurate for
small <code>x</code>. For small <code>x</code> the algorithm is based on
the expansion (exp(x)-1)/x = 1 + x/2 + x^2/(2*3) + x^3/(2*3*4) + … .</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::exprel_2(x)</p>

<p>Computes the quantity 2(exp(x)-1-x)/x^2 using an algorithm that is accurate
for small <code>x</code>. For small <code>x</code> the algorithm is based
on the expansion 2(exp(x)-1-x)/x^2 = 1 + x/3 + x^2/(3*4) + x^3/(3*4*5) + …
.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::exprel_n(n, x)</p>

<p>Computes the N-relative exponential, which is the <code>n</code>-th
generalization of the methods <code>exprel</code> and <code>exprel2</code>.
The N-relative exponential is given by,</p>

<pre>exprel_N(x) = N!/x^N (exp(x) - sum_{k=0}^{N-1} x^k/k!)
            = 1 + x/(N+1) + x^2/((N+1)(N+2)) + ...
            = 1F1 (1,1+N,x)</pre>
</li></ul>

<h3 id="label-Exponentiation+With+Error+Estimate">Exponentiation With Error Estimate<span><a href="#label-Exponentiation+With+Error+Estimate">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::exp_err_e(x, dx)</p>

<p>Exponentiates <code>x</code> with an associated absolute error
<code>dx</code>.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::exp_err_e10_e(x, dx)</p>

<p>Exponentiates a quantity <code>x</code> with an associated absolute error
<code>dx</code> using the <code>GSL::Sf::Result_e10</code> type to return a
result with extended range.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::exp_mult_err_e(x, dx, y, dy)</p>

<p>Computes the product y exp(x) for the quantities <code>x, y</code> with
associated absolute errors <code>dx, dy</code>.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::exp_mult_err_e10_e(x, dx, y, dy)</p>

<p>Computes the product y exp(x) for the quantities <code>x, y</code> with
associated absolute errors <code>dx, dy</code>  using the
<code>GSL::Sf::Result_e10</code> type to return a result with extended
range.</p>
</li></ul>

<h2 id="label-Exponential+Integrals">Exponential Integrals<span><a href="#label-Exponential+Integrals">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<h3 id="label-Exponential+Integral">Exponential Integral<span><a href="#label-Exponential+Integral">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::expint_E1(x)</p>

<p>Computes the exponential integral E_1(x),</p>

<pre>E_1(x) := int_1^infty dt exp(-xt)/t.</pre>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::expint_E2(x)</p>

<p>Computes the second-order exponential integral E_2(x),</p>

<pre>E_2(x) := int_1^infty dt exp(-xt)/t^2.</pre>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::expint_En(n, x)</p>

<p>Computes the exponential integral E_n(n, x) of order <code>n</code>. (&gt;=
GSL-1.10)</p>
</li></ul>

<h3 id="label-Ei%28x%29">Ei(x)<span><a href="#label-Ei%28x%29">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::expint_Ei(x)</p>

<p>Computes the exponential integral E_i(x),</p>

<pre>Ei(x) := - PV(int_{-x}^infty dt exp(-t)/t)</pre>

<p>where PV denotes the principal value of the integral.</p>
</li></ul>

<h3 id="label-Hyperbolic+Integrals">Hyperbolic Integrals<span><a href="#label-Hyperbolic+Integrals">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::Shi(x)</p>

<p>Computes the integral Shi(x) = int_0^x dt sinh(t)/t.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::Chi(x)</p>

<p>Computes the integral</p>

<pre>Chi(x) := Re[ gamma_E + log(x) + int_0^x dt (cosh[t]-1)/t] ,</pre>

<p>where gamma_E is the Euler constant (available as the constant
<code>GSL::M_EULER</code>).</p>
</li></ul>

<h3 id="label-Ei_3%28x%29">Ei_3(x)<span><a href="#label-Ei_3%28x%29">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::expint_3(x)</p>

<p>Computes the exponential integral Ei_3(x) = int_0^x dt exp(-t^3) for x
&gt;= 0</p>
</li></ul>

<h3 id="label-Trigonometric+Integrals">Trigonometric Integrals<span><a href="#label-Trigonometric+Integrals">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::Si(x)</p>

<p>Computes the Sine integral Si(x) = int_0^x dt sin(t)/t.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::Ci(x)</p>

<p>Computes the Cosine integral Ci(x) = -int_x^infty dt cos(t)/t for x &gt; 0.</p>
</li></ul>

<h3 id="label-Arctangent+Integral">Arctangent Integral<span><a href="#label-Arctangent+Integral">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::atanint(x)</p>

<p>Computes the Arctangent integral AtanInt(x) = int_0^x dt arctan(t)/t.</p>
</li></ul>

<h2 id="label-Fermi-Dirac+Functions">Fermi-Dirac Functions<span><a href="#label-Fermi-Dirac+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<h3 id="label-Complete+Fermi-Dirac+Integrals">Complete Fermi-Dirac Integrals<span><a href="#label-Complete+Fermi-Dirac+Integrals">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>The complete Fermi-Dirac integral F_j(x) is given by,</p>

<pre>F_j(x)   := (1/r Gamma(j+1)) int_0^infty dt (t^j / (exp(t-x) + 1))</pre>
<hr>
<ul><li>
<p>GSL::Sf::fermi_dirac_m1(x)</p>

<p>Computes the complete Fermi-Dirac integral with an index of -1. This
integral is given by F_{-1}(x) = e^x / (1 + e^x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::fermi_dirac_0(x)</p>

<p>Computes the complete Fermi-Dirac integral with an index of 0. This
integral is given by F_0(x) = ln(1 + e^x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::fermi_dirac_1(x)</p>

<p>Compute the complete Fermi-Dirac integral with an index of 1, F_1(x) =
int_0^infty dt (t /(exp(t-x)+1)).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::fermi_dirac_2(x)</p>

<p>Computes the complete Fermi-Dirac integral with an index of 2, F_2(x) =
(1/2) int_0^infty dt (t^2 /(exp(t-x)+1)).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::fermi_dirac_int(j, x)</p>

<p>Computes the complete Fermi-Dirac integral with an integer index of
<code>j</code>, F_j(x) = (1/Gamma(j+1)) int_0^infty dt (t^j /(exp(t-x)+1)).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::fermi_dirac_mhalf(x)</p>

<p>Computes the complete Fermi-Dirac integral F_{-1/2}(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::fermi_dirac_half(x)</p>

<p>Computes the complete Fermi-Dirac integral F_{1/2}(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::fermi_dirac_3half(x)</p>

<p>Computes the complete Fermi-Dirac integral F_{3/2}(x).</p>
</li></ul>

<h3 id="label-Incomplete+Fermi-Dirac+Integrals">Incomplete Fermi-Dirac Integrals<span><a href="#label-Incomplete+Fermi-Dirac+Integrals">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::fermi_dirac_inc_0(x, b)</p>

<p>Computes the incomplete Fermi-Dirac integral with an index of zero,
F_0(x,b) = ln(1 + e^{b-x}) - (b-x).</p>
</li></ul>

<h2 id="label-Gamma+Function">Gamma Function<span><a href="#label-Gamma+Function">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>The Gamma function is defined by the following integral,</p>

<pre>Gamma(x) = int_0^infty dt  t^{x-1} exp(-t)</pre>

<p>Further information on the Gamma function can be found in Abramowitz &amp;
Stegun, Chapter 6.</p>
<hr>
<ul><li>
<p>GSL::Sf::gamma(x)</p>

<p>Computes the Gamma function, subject to <code>x</code> not being a negative
integer. The function is computed using the real Lanczos method. The
maximum value of <code>x</code> such that Gamma(x) is not considered an
overflow is given by the constant <code>GSL::Sf::GAMMA_XMAX</code> and is
171.0.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::lngamma(x)</p>

<p>Computes the logarithm of the Gamma function, log(Gamma(x)), subject to
<code>x</code> not a being negative integer. For x&lt;0 the real part of
log(Gamma(x)) is returned, which is equivalent to log(|Gamma(x)|). The
function is computed using the real Lanczos method.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::lngamma_sgn_e(x)</p>

<p>Computes the sign of the gamma function and the logarithm its magnitude,
subject to <code>x</code> not being a negative integer, and returns the
result as an array of 2 elements, <code>[result, sng]</code>. The function
is computed using the real Lanczos method. The value of the gamma function
can be reconstructed using the relation Gamma(x) = sgn * exp(result).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::gammastar(x)</p>

<p>Computes the regulated Gamma Function Gamma^*(x) for x &gt; 0. The
regulated gamma function is given by,</p>

<pre>Gamma^*(x) = Gamma(x)/(sqrt{2 pi} x^{(x-1/2)} exp(-x))
           = (1 + (1/12x) + ...)  for x -&gt; infty</pre>

<p>and is a useful suggestion of Temme.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::gammainv(x)</p>

<p>Computes the reciprocal of the gamma function, 1/Gamma(x) using the real
Lanczos method.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::ngamma_complex_e(zr, zi)</p>

<p>These method compute log(Gamma(z)) for complex z = zr + i zi and z not a
negative integer, using the complex Lanczos method. The result is returned
as an array of 2 elements, <code>[lnr, arg, status]</code>, where lnr =
log|Gamma(z)| and arg = arg(Gamma(z)) in (-pi,pi]. Note that the phase part
(arg) is not well-determined when |z| is very large, due to inevitable
roundoff in restricting to (-pi,pi]. This will result in a
<code>GSL::ELOSS</code> error when it occurs. The absolute value part
(lnr), however, never suffers from loss of precision.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::taylorcoeff(n, x)</p>

<p>Computes the Taylor coefficient x^n / n! for x &gt;= 0, n &gt;= 0.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::fact(n)</p>

<p>Computes the factorial n!. The factorial is related to the Gamma function
by n! = Gamma(n+1).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::doublefact(n)</p>

<p>Computes the double factorial n!! = n(n-2)(n-4)… .</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::lnfact(n)</p>

<p>Computes the logarithm of the factorial of <code>n</code>, log(n!). The
algorithm is faster than computing ln(Gamma(n+1)) via
<code>GSL::Sf::lngamma</code> for n &lt; 170, but defers for larger n.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::lndoublefact(n)</p>

<p>Computes the logarithm of the double factorial of n, log(n!!).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::choose(n, m)</p>

<p>Computes the combinatorial factor n choose m = n!/(m!(n-m)!).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::lnchoose(n, m)</p>

<p>Computes the logarithm of n choose m. This is equivalent to the sum log(n!)
- log(m!) - log((n-m)!).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::poch(a, x)</p>

<p>Computes the Pochhammer symbol (a)_x := Gamma(a + x)/Gamma(a), subject to
<code>a</code> and <code>a+x</code> not being negative integers. The
Pochhammer symbol is also known as the Apell symbol.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::lnpoch(a, x)</p>

<p>Computes the logarithm of the Pochhammer symbol, log((a)_x) = log(Gamma(a +
x)/Gamma(a)) for a &gt; 0, a+x &gt; 0.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::lnpoch_sgn_e(a, x)</p>

<p>Computes the sign of the Pochhammer symbol and the logarithm of its
magnitude, subject to a, a+x not being negative integers. The result is
returned as an array of 2 elements, <code>[result, sng]</code>, where
result = log(|(a)_x|), sgn = sgn((a)_x), and (a)_x := Gamma(a +
x)/Gamma(a).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::pochrel(a, x)</p>

<p>Computes the relative Pochhammer symbol ((a,x) - 1)/x where (a,x) = (a)_x
:= Gamma(a + x)/Gamma(a).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::gamma_inc_Q(a, x)</p>

<p>Computes the normalized incomplete Gamma Function Q(a,x) = 1/Gamma(a)
int_x^infty dt t^{a-1} exp(-t) for a &gt; 0, x &gt;= 0.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::gamma_inc_P(a, x)</p>

<p>Computes the complementary normalized incomplete Gamma Function P(a,x) =
1/Gamma(a) int_0^x dt t^{a-1} exp(-t) for a &gt; 0, x &gt;= 0. Note that
Abramowitz &amp; Stegun call P(a,x) the incomplete gamma function (section
6.5).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::gamma_inc(a, x)</p>

<p>Computes the incomplete Gamma Function the normalization factor included in
the previously defined functions: Gamma(a,x) = int_x^infty dt t^{a-1}
exp(-t) for a real and x &gt;= 0.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::beta(a, b)</p>

<p>Computes the Beta Function, B(a,b) = Gamma(a)Gamma(b)/Gamma(a+b) for a &gt;
0, b &gt; 0.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::lnbeta(a, b)</p>

<p>Computes the logarithm of the Beta Function, log(B(a,b)) for a &gt; 0, b
&gt; 0.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::beta_inc(a, b, x)</p>

<p>Computes the normalize incomplete Beta function B_x(a,b)/B(a,b) for a &gt;
0, b &gt; 0, and 0 &lt;= x &lt;= 1.</p>
</li></ul>

<h2 id="label-Gegenbauer+Functions">Gegenbauer Functions<span><a href="#label-Gegenbauer+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h2>
<hr>
<ul><li>
<p>GSL::Sf::gegenpoly_1(lambda, x)</p>
</li><li>
<p>GSL::Sf::gegenpoly_2(lambda, x)</p>
</li><li>
<p>GSL::Sf::gegenpoly_3(lambda, x)</p>

<p>These methods evaluate the Gegenbauer polynomials C^{(lambda)}_n(x) using
explicit representations for n =1, 2, 3.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::gegenpoly_n(n, lambda, x)</p>

<p>This evaluates the Gegenbauer polynomial C^{(lambda)}_n(x) for a specific
value of <code>n, lambda, x</code> subject to lambda &gt; -1/2, n &gt;= 0.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::gegenpoly_array(nmax, lambda, x)</p>

<p>This method computes Gegenbauer polynomials C^{(lambda)}_n(x) for n = 0, 1,
2, …, nmax, subject to lambda &gt; -1/2, nmax &gt;= 0. The result is
returned as a <code>GSL::Vector</code> object.</p>
</li></ul>

<h2 id="label-Hypergeometric+Functions">Hypergeometric Functions<span><a href="#label-Hypergeometric+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h2>
<hr>
<ul><li>
<p>GSL::Sf::hyperg_0F1(c, x)</p>

<p>Computes the hypergeometric function 0F1(c, x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::hyperg_1F1_int(m, n, x)</p>

<p>Computes the confluent hypergeometric function 1F1(m,n,x) = M(m,n,x) for
integer parameters <code>m, n</code>.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::hyperg_1F1(a, b, x)</p>

<p>Computes the confluent hypergeometric function 1F1(a,b,x) = M(a,b,x) for
general parameters <code>a, b</code>.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::hyperg_U_int(m, n, x)</p>

<p>Computes the confluent hypergeometric function U(m,n,x) for integer
parameters <code>m, n</code>.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::hyperg_U_int_e10_e(m, n, x)</p>

<p>Computes the confluent hypergeometric function U(m,n,x) for integer
parameters <code>m, n</code> using the <code>GSL::Sf::Result_e10</code>
type to return a result with extended range.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::hyperg_U(a, b, x)</p>

<p>Computes the confluent hypergeometric function U(a,b,x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::hyperg_U_e10_e(a, b, x)</p>

<p>Computes the confluent hypergeometric function U(a,b,x) using the
<code>GSL::Sf::Result_e10</code>  type to return a result with extended
range.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::hyperg_2F1(a, b, c, x)</p>
</li><li>
<p>GSL::Sf::hyperg_2F1_e(a, b, c, x)</p>

<p>These methods compute the Gauss hypergeometric function 2F1(a,b,c,x) for
|x| &lt; 1. If the arguments (a,b,c,x) are too close to a singularity then
the function can return the error code <code>GSL::EMAXITER</code> when the
series approximation converges too slowly. This occurs in the region of
x=1, c - a - b = m for integer m.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::hyperg_2F1_conj(aR, aI, c, x)</p>

<p>Computes the Gauss hypergeometric function 2F1(a_R + i a_I, a_R - i a_I, c,
x) with complex parameters for |x| &lt; 1.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::hyperg_2F1_renorm(a, b, c, x)</p>

<p>Computes the renormalized Gauss hypergeometric function 2F1(a,b,c,x) /
Gamma© for |x| &lt; 1.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::hyperg_2F1_renorm(aR, aI, c, x)</p>

<p>Computes the renormalized Gauss hypergeometric function 2F1(a_R + i a_I,
a_R - i a_I, c, x) / Gamma© for |x| &lt; 1.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::hyperg_2F0(a, b, x)</p>

<p>Computes the hypergeometric function 2F0(a,b,x). The series representation
is a divergent hypergeometric series. However, for x &lt; 0 we have
2F0(a,b,x) = (-1/x)^a U(a,1+a-b,-1/x).</p>
</li></ul>

<h2 id="label-Laguerre+Functions">Laguerre Functions<span><a href="#label-Laguerre+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>The Laguerre polynomials are defined in terms of confluent hypergeometric
functions as L^a_n(x) = ((a+1)_n / n!) 1F1(-n,a+1,x).</p>
<hr>
<ul><li>
<p>GSL::Sf::laguerre_1(a, x)</p>
</li><li>
<p>GSL::Sf::laguerre_2(a, x)</p>
</li><li>
<p>GSL::Sf::laguerre_3(a, x)</p>

<p>These methods evaluate the generalized Laguerre polynomials L^a_1(x),
L^a_2(x), L^a_3(x) using explicit representations.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::laguerre_n(n, a, x)</p>

<p>This evaluates the generalized Laguerre polynomials L^a_n(x) for a &gt; -1,
n &gt;= 0.</p>
</li></ul>

<h2 id="label-Lambert+W+Functions">Lambert W Functions<span><a href="#label-Lambert+W+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>Lambert&#39;s W functions, W(x), are defined to be solutions of the
equation W(x) exp(W(x)) = x. This function has multiple branches for x &lt;
0; however, it has only two real-valued branches. We define W_0(x) to be
the principal branch, where W &gt; -1 for x &lt; 0, and W_{-1}(x) to be the
other real branch, where W &lt; -1 for x &lt; 0.</p>
<hr>
<ul><li>
<p>GSL::Sf::lambert_W0(x)</p>

<p>This computes the principal branch of the Lambert W function, W_0(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::lambert_Wm1(x)</p>

<p>This computes the secondary real-valued branch of the Lambert W function,
W_{-1}(x).</p>
</li></ul>

<h2 id="label-Legendre+Functions+and+Spherical+Harmonics">Legendre Functions and Spherical Harmonics<span><a href="#label-Legendre+Functions+and+Spherical+Harmonics">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<h3 id="label-Legendre+Polynomials">Legendre Polynomials<span><a href="#label-Legendre+Polynomials">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::legendre_P1(x)</p>
</li><li>
<p>GSL::Sf::legendre_P2(x)</p>
</li><li>
<p>GSL::Sf::legendre_P3(x)</p>

<p>These methods evaluate the Legendre polynomials P_l(x) using explicit
representations for l=1, 2, 3.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::legendre_Pl(l, x)</p>

<p>This evaluates the Legendre polynomial P_l(x) for a specific value of
<code>l, x</code>, subject to l &gt;= 0, |x| &lt;= 1.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::legendre_Pl_array(lmax, x)</p>

<p>This function computes Legendre polynomials P_l(x) for l = 0, …, lmax, and
returns the result as a <code>GSL::Vector</code> object.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::legendre_Q0(x)</p>

<p>This computes the Legendre function Q_0(x) for x &gt; -1, x != 1.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::legendre_Q1(x)</p>

<p>This computes the Legendre function Q_1(x) for x &gt; -1, x != 1.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::legendre_Ql(l, x)</p>

<p>This computes the Legendre function Q_l(x) for x &gt; -1, x != 1 and l
&gt;= 0.</p>
</li></ul>

<h3 id="label-Associated+Legendre+Polynomials+and+Spherical+Harmonics">Associated Legendre Polynomials and Spherical Harmonics<span><a href="#label-Associated+Legendre+Polynomials+and+Spherical+Harmonics">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>The following functions compute the associated Legendre Polynomials
P_l^m(x). Note that this function grows combinatorially with <code>l</code>
and can overflow for <code>l</code> larger than about 150. There is no
trouble for small <code>m</code>, but overflow occurs when <code>m</code>
and <code>l</code> are both large. Rather than allow overflows, these
functions refuse to calculate P_l^m(x) and return <code>GSL::EOVRFLW</code>
when they can sense that <code>l</code> and <code>m</code> are too big. If
you want to calculate a spherical harmonic, then do not use these
functions. Instead use <code>GSL::Sf::legendre_sphPlm()</code> below, which
uses a similar recursion, but with the normalized functions.</p>
<hr>
<ul><li>
<p>GSL::Sf::legendre_Plm(l, m, x)</p>
</li><li>
<p>GSL::Sf::legendre_Plm_e(l, m, x)</p>

<p>These methods compute the associated Legendre polynomial P_l^m(x) for m
&gt;= 0, l &gt;= m, |x| &lt;= 1.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::legendre_Plm_array(lmax, m, x)</p>

<p>This method computes Legendre polynomials P_l^m(x) for m &gt;= 0, l = |m|,
…, lmax, |x| &lt;= 1, and returns the result as a <code>GSL::Vector</code>
object.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::legendre_sphPlm(l, m, x)</p>
</li><li>
<p>GSL::Sf::legendre_sphPlm_e(l, m, x)</p>

<p>These methods compute the normalized associated Legendre polynomial
sqrt{(2l+1)/(4pi)} sqrt{(l-m)!/(l+m)!} P_l^m(x) suitable for use in
spherical harmonics. The parameters must satisfy m &gt;= 0, l &gt;= m, |x|
&lt;= 1. Theses routines avoid the overflows that occur for the standard
normalization of P_l^m(x).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::legendre_sphPlm_array(lmax, m, x)</p>

<p>This method computes an array of normalized associated Legendre functions
sqrt{(2l+1)/(4pi)} sqrt{(l-m)!/(l+m)!} P_l^m(x)$ for m &gt;= 0, l = |m|, …,
lmax, |x| &lt;= 1.0, and returns the result as a <code>GSL::Vector</code>
object.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::legendre_array_size(lmax, m)</p>

<p>This returns the size of resulting array needed for the array versions of
P_l^m(x), lmax - m + 1.</p>
</li></ul>

<h3 id="label-Conical+Functions">Conical Functions<span><a href="#label-Conical+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>The Conical Functions P^mu_{-(1/2)+i lambda}(x), Q^mu_{-(1/2)+i lambda} are
described in Abramowitz &amp; Stegun, Section 8.12.</p>
<hr>
<ul><li>
<p>GSL::Sf::conicalP_half(lambda, x)</p>

<p>Computes the irregular Spherical Conical Function P^{1/2}_{-1/2 + i
lambda}(x) for x &gt; -1.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::conicalP_mhalf(lambda, x)</p>

<p>Computes the regular Spherical Conical Function P^{-1/2}_{-1/2 + i
lambda}(x) for x &gt; -1.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::conicalP_0(lambda, x)</p>
</li><li>
<p>GSL::Sf::conicalP_1(lambda, x)</p>

<p>These methods compute the conical function P^0_{-1/2 + i lambda}(x),
P^1_{-1/2 + i lambda}(x)for x &gt; -1.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::conicalP_sph_reg(l, lambda, x)</p>

<p>Computes the Regular Spherical Conical Function P^{-1/2-l}_{-1/2 + i
lambda}(x) for x &gt; -1, l &gt;= -1.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::conicalP_cyc_reg(m, lambda, x)</p>

<p>Computes the Regular Cylindrical Conical Function P^{-m}_{-1/2 + i
lambda}(x) for x &gt; -1, m &gt;= -1.</p>
</li></ul>

<h3 id="label-Radial+Functions+for+Hyperbolic+Space">Radial Functions for Hyperbolic Space<span><a href="#label-Radial+Functions+for+Hyperbolic+Space">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>The following spherical functions are specializations of Legendre functions
which give the regular eigenfunctions of the Laplacian on a 3-dimensional
hyperbolic space H3d. Of particular interest is the flat limit, lambda to
infty, eta to 0, lambda eta fixed.</p>
<hr>
<ul><li>
<p>GSL::Sf::legendre_H3d_0(lambda, eta)</p>

<p>Computes the zeroth radial eigenfunction of the Laplacian on the
3-dimensional hyperbolic space, L^{H3d}_0(lambda,eta) := sin(lambda
eta)/(lambda sinh(eta)) for eta &gt;= 0. In the flat limit this takes the
form L^{H3d}_0(lambda, eta) = j_0( lambda eta).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::legendre_H3d_1(lambda, eta)</p>

<p>Computes the first radial eigenfunction of the Laplacian on the
3-dimensional hyperbolic space, L^{H3d}_1(lambda, eta) := 1/sqrt{lambda^2 +
1} sin(lambda eta)/(lambda sinh(eta)) (coth(eta) - lambda cot(lambda eta))
for eta &gt;= 0. In the flat limit this takes the form L^{H3d}_1(lambda,
eta) = j_1( lambda eta).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::legendre_H3d(l, lambda, eta)</p>

<p>Computes the <code>l</code>-th radial eigenfunction of the Laplacian on the
3-dimensional hyperbolic space eta &gt;= 0, l &gt;= 0. In the flat limit
this takes the form L^{H3d}_l(lambda, eta) = j_l(lambda eta).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::legendre_H3d_array(lmax, lambda, eta)</p>

<p>This method computes radial eigenfunctions L^{H3d}_l(lambda, eta) for 0
&lt;= l &lt;= lmax, and returns the result as a <code>GSL::Vector</code>
object.</p>
</li></ul>

<h2 id="label-Logarithm+and+Related+Functions">Logarithm and Related Functions<span><a href="#label-Logarithm+and+Related+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h2>
<hr>
<ul><li>
<p>GSL::Sf::log(x)</p>

<p>Computes the logarithm of <code>x</code>, log(x), for x &gt; 0.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::log_abs(x)</p>

<p>Computes the logarithm of the magnitude of <code>x</code>, log(|x|), for x
!= 0.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::complex_log_e(zr, zi)</p>
</li><li>
<p>GSL::Sf::complex_log_e(z)</p>

<p>This method computes the complex logarithm of z = z_r + i z_i. The results
are returned as an array <code>[lnr, theta]</code> such that exp(lnr + i
theta) = z_r + i z_i, where theta lies in the range [-pi, pi].</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::log_1plusx(x)</p>

<p>Computes log(1 + x) for x &gt; -1 using an algorithm that is accurate for
small x.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::log_1plusx_mx(x)</p>

<p>Computes log(1 + x) - x for x &gt; -1 using an algorithm that is accurate
for small x.</p>
</li></ul>

<h2 id="label-Mathieu+functions">Mathieu functions<span><a href="#label-Mathieu+functions">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>The methods described in this section compute the angular and radial
Mathieu functions, and their characteristic values. Mathieu functions are
the solutions of the following two differential equations: The angular
Mathieu functions ce_r(x,q), se_r(x,q) are the even and odd periodic
solutions of the first equation, which is known as Mathieu&#39;s equation.
These exist only for the discrete sequence of characteristic values
a=a_r(q) (even-periodic) and a=b_r(q) (odd-periodic).</p>

<p>The radial Mathieu functions Mc^{(j)}_{r}(z,q), Ms^{(j)}_{r}(z,q) are the
solutions of the second equation, which is referred to as Mathieu&#39;s
modified equation. The radial Mathieu functions of the first, second, third
and fourth kind are denoted by the parameter <code>j</code>, which takes
the value 1, 2, 3 or 4.</p>

<p>For more information on the Mathieu functions, see Abramowitz and Stegun,
Chapter 20.</p>

<h3 id="label-Mathieu+Function+Workspace">Mathieu Function Workspace<span><a href="#label-Mathieu+Function+Workspace">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>The Mathieu functions can be computed for a single order or for multiple
orders, using array-based routines.</p>
<hr>
<ul><li>
<p>GSL::Sf::Mathieu.alloc(n, qmax)</p>

<p>This method returns a workspace for the array versions of the Mathieu
routines. The arguments <code>n</code> and <code>qmax</code> specify the
maximum order and q-value of Mathieu functions which can be computed with
this workspace.</p>
</li></ul>

<h3 id="label-Mathieu+Function+Characteristic+Values">Mathieu Function Characteristic Values<span><a href="#label-Mathieu+Function+Characteristic+Values">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::mathieu_a(n, q)</p>
</li><li>
<p>GSL::Sf::mathieu_a_e(n, q)</p>
</li><li>
<p>GSL::Sf::mathieu_b(n, q)</p>
</li><li>
<p>GSL::Sf::mathieu_b_e(n, q)</p>

<p>These methodss compute the characteristic values a_n(q), b_n(q) of the
Mathieu functions ce_n(q,x) and se_n(q,x), respectively.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::mathieu_a_array(nmin, nmax, q, work)</p>
</li><li>
<p>GSL::Sf::mathieu_b_array(nminm nmax, q, work)</p>

<p>These methods compute a series of Mathieu characteristic values a_n(q),
b_n(q) for n from <code>nmin</code> to <code>nmax</code> inclusive, and
return the results as a <code>GSL::Vector</code> object.</p>
</li></ul>

<h3 id="label-Angular+Mathieu+Functions">Angular Mathieu Functions<span><a href="#label-Angular+Mathieu+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::mathieu_ce(n, q, x)</p>
</li><li>
<p>GSL::Sf::mathieu_ce_e(n, q, x)</p>
</li><li>
<p>GSL::Sf::mathieu_se(n, q, x)</p>
</li><li>
<p>GSL::Sf::mathieu_se_e(n, q, x)</p>

<p>These methods compute the angular Mathieu functions ce_n(q,x) and
se_n(q,x), respectively.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::mathieu_ce_array(nmin, nmax, q, x, work)</p>
</li><li>
<p>GSL::Sf::mathieu_se_array(nmin, nmax, q, x, work)</p>

<p>These methods compute a series of the angular Mathieu functions ce_n(q,x)
and se_n(q,x) of order n from <code>nmin</code> to <code>nmax</code>
inclusive, and return the results as a <code>GSL::Vector</code> object.</p>
</li></ul>

<h3 id="label-Radial+Mathieu+Functions">Radial Mathieu Functions<span><a href="#label-Radial+Mathieu+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::mathieu_Mc(j, n, q, x)</p>
</li><li>
<p>GSL::Sf::mathieu_Mc_e(j, n, q, x)</p>
</li><li>
<p>GSL::Sf::mathieu_Ms(j, n, q, x)</p>
</li><li>
<p>GSL::Sf::mathieu_Ms_e(j, n, q, x)</p>

<p>These methods compute the radial <code>j</code>-th kind Mathieu functions
Mc_n^{(j)}(q,x) and Ms_n^{(j)}(q,x) of order <code>n</code>.</p>

<p>The allowed values of <code>j</code> are 1 and 2. The functions for <code>j
= 3,4</code> can be computed as M_n^{(3)} = M_n^{(1)} + iM_n^{(2)} and
M_n^{(4)} = M_n^{(1)} - iM_n^{(2)}, where M_n^{(j)} = Mc_n^{(j)} or
Ms_n^{(j)}.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::mathieu_Mc_array(j, nmin, nmax, q, x, work)</p>
</li><li>
<p>GSL::Sf::mathieu_Ms_array(j, nmin, nmax, q, x, work)</p>

<p>These methods compute a series of the radial Mathieu functions of kind
<code>j</code>, with order from <code>nmin</code> to <code>nmax</code>
inclusive, and return the results as a <code>GSL::Vector</code> object.</p>
</li></ul>

<h2 id="label-Power+Functions">Power Functions<span><a href="#label-Power+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h2>
<hr>
<ul><li>
<p>GSL::Sf::pow_int(x, n)</p>
</li><li>
<p>GSL::Sf::pow_int_e(x, n)</p>

<p>These methods compute the power x^n for integer n. The power is computed
using the minimum number of multiplications. For example, x^8 is computed
as ((x^2)^2)^2, requiring only 3 multiplications. For reasons of
efficiency, these functions do not check for overflow or underflow
conditions.</p>
</li></ul>

<h2 id="label-Psi+%28Digamma%29+Function">Psi (Digamma) Function<span><a href="#label-Psi+%28Digamma%29+Function">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>The polygamma functions of order <code>m</code> defined by psi^{(m)}(x) =
(d/dx)^m psi(x) = (d/dx)^{m+1} log(Gamma(x)), where psi(x) =
Gamma&#39;(x)/Gamma(x) is known as the digamma function.</p>

<h3 id="label-Digamma+Function">Digamma Function<span><a href="#label-Digamma+Function">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::psi_int(n)</p>

<p>Computes the digamma function psi(n) for positive integer <code>n</code>.
The digamma function is also called the Psi function.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::psi(x)</p>

<p>Computes the digamma function psi(x) for general x, x != 0.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::psi_1piy(x)</p>

<p>Computes the real part of the digamma function on the line 1+i y, Re[psi(1
+ i y)].</p>
</li></ul>

<h3 id="label-Trigamma+Function">Trigamma Function<span><a href="#label-Trigamma+Function">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::psi_1_int(n)</p>

<p>Computes the Trigamma function psi&#39;(n) for positive integer
<code>n</code>.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::psi_1(x)</p>

<p>Computes the Trigamma function psi&#39;(x) for general <code>x</code>.</p>
</li></ul>

<h3 id="label-Polygamma+Function">Polygamma Function<span><a href="#label-Polygamma+Function">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::psi_n(m, x)</p>

<p>Computes the polygamma function psi^{(m)}(x) for m &gt;= 0, x &gt; 0.</p>
</li></ul>

<h2 id="label-Synchrotron+Functions">Synchrotron Functions<span><a href="#label-Synchrotron+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h2>
<hr>
<ul><li>
<p>GSL::Sf::synchrotron_1(x)</p>

<p>Computes the first synchrotron function x int_x^infty dt K_{5/3}(t) for x
&gt;= 0.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::synchrotron_2(x)</p>

<p>Computes the second synchrotron function x K_{2/3}(x) for x &gt;= 0.</p>
</li></ul>

<h2 id="label-Transport+Functions">Transport Functions<span><a href="#label-Transport+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>The transport functions J(n,x) are defined by the integral representations
J(n,x) := int_0^x dt t^n e^t /(e^t - 1)^2.</p>
<hr>
<ul><li>
<p>GSL::Sf::transport_2(x)</p>
</li><li>
<p>GSL::Sf::transport_3(x)</p>
</li><li>
<p>GSL::Sf::transport_4(x)</p>
</li><li>
<p>GSL::Sf::transport_5(x)</p>

<p>These methods compute the transport function J(n, x), for n = 2, 3, 4, and
5.</p>
</li></ul>

<h2 id="label-Trigonometric+Functions">Trigonometric Functions<span><a href="#label-Trigonometric+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<h3 id="label-Circular+Trigonometric+Functions">Circular Trigonometric Functions<span><a href="#label-Circular+Trigonometric+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::sin(x)</p>
</li><li>
<p>GSL::Sf::cos(x)</p>
</li><li>
<p>GSL::Sf::hypot(x, y)</p>

<p>sqrt{x^2 + y^2}</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::sinc(x)</p>

<p>sinc(x) = sin(pi x) / (pi x)</p>
</li></ul>

<h3 id="label-Trigonometric+Functions+for+Complex+Arguments">Trigonometric Functions for Complex Arguments<span><a href="#label-Trigonometric+Functions+for+Complex+Arguments">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::complex_sin_e(zr, zi)</p>
</li><li>
<p>GSL::Sf::complex_sin_e(z)</p>
</li><li>
<p>GSL::Sf::complex_cos_e(zr, zi)</p>
</li><li>
<p>GSL::Sf::complex_cos_e(z)</p>
</li><li>
<p>GSL::Sf::complex_logsin_e(zr, zi)</p>
</li><li>
<p>GSL::Sf::complex_logsin_e(z)</p>
</li></ul>

<h3 id="label-Hyperbolic+Trigonometric+Functions">Hyperbolic Trigonometric Functions<span><a href="#label-Hyperbolic+Trigonometric+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::lnsinh(x)</p>
</li><li>
<p>GSL::Sf::lncosh(x)</p>
</li></ul>

<h3 id="label-Conversion+Functions">Conversion Functions<span><a href="#label-Conversion+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::polar_to_rect(r, theta)</p>
</li><li>
<p>GSL::Sf::rect_to_polar(x, y)</p>
</li></ul>

<h3 id="label-Restriction+Functions">Restriction Functions<span><a href="#label-Restriction+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::angle_restrict_symm(theta)</p>

<p>This forces the angle <code>theta</code> to lie in the range (-pi, pi].</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::angle_restrict_pos(theta)</p>

<p>This forces the angle <code>theta</code> to lie in the range [0, 2pi).</p>
</li></ul>

<h3 id="label-Trigonometric+Functions+With+Error+Estimates">Trigonometric Functions With Error Estimates<span><a href="#label-Trigonometric+Functions+With+Error+Estimates">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::sin_err(x, dx)</p>

<p>Computes the sine of an angle <code>x</code> with an associated absolute
error <code>dx</code>, sin(x +- dx).</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::cos_err(x, dx)</p>

<p>Computes the cosine of an angle <code>x</code> with an associated absolute
error <code>dx</code>, cos(x +- dx).</p>
</li></ul>

<h2 id="label-Zeta+Functions">Zeta Functions<span><a href="#label-Zeta+Functions">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<h3 id="label-Riemann+Zeta+Function">Riemann Zeta Function<span><a href="#label-Riemann+Zeta+Function">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>The Riemann zeta function is defined by the infinite sum zeta(s) =
sum_{k=1}^infty k^{-s}.</p>
<hr>
<ul><li>
<p>GSL::Sf::zeta_int(n)</p>

<p>Computes the Riemann zeta function zeta(n) for integer n, n != 1.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::zeta(s)</p>

<p>Computes the Riemann zeta function zeta(s) for arbitrary s, s != 1.</p>
</li></ul>

<h3 id="label-Riemann+Zeta+Function+Minus+One">Riemann Zeta Function Minus One<span><a href="#label-Riemann+Zeta+Function+Minus+One">&para;</a> <a href="#documentation">&uarr;</a></span></h3>
<hr>
<ul><li>
<p>GSL::Sf::zetam1_int(n)</p>

<p>Computes zeta(n) - 1 for integer n, n != 1.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::zetam1(s)</p>

<p>Computes zeta(s) - 1 for arbitrary s, s != 1.</p>
</li></ul>

<h3 id="label-Hurwitz+Zeta+Function">Hurwitz Zeta Function<span><a href="#label-Hurwitz+Zeta+Function">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>The Hurwitz zeta function is defined by zeta(s,q) = sum_0^infty (k+q)^{-s}.</p>
<hr>
<ul><li>
<p>GSL::Sf::hzeta(s, q)</p>

<p>Computes the Hurwitz zeta function zeta(s,q) for s &gt; 1, q &gt; 0.</p>
</li></ul>

<h3 id="label-Eta+Function">Eta Function<span><a href="#label-Eta+Function">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>The eta function is defined by eta(s) = (1-2^{1-s}) zeta(s).</p>
<hr>
<ul><li>
<p>GSL::Sf::eta_int(n)</p>

<p>Computes the eta function eta(n) for integer n.</p>
</li></ul>
<hr>
<ul><li>
<p>GSL::Sf::eta(s)</p>

<p>Computes the eta function eta(s) for arbitrary s.</p>
</li></ul>

<p><a href="poly_rdoc.html">prev</a> <a href="vector_rdoc.html">next</a></p>

<p><a href="ref_rdoc.html">Reference index</a> <a href="index.html">top</a></p>
</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://rdoc.rubyforge.org">RDoc</a> 4.1.2.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

